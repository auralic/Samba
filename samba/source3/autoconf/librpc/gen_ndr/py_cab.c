
/* Python wrapper functions auto-generated by pidl */
#define PY_SSIZE_T_CLEAN 1 /* We use Py_ssize_t for PyArg_ParseTupleAndKeywords */
#include <Python.h>
#include "python/py3compat.h"
#include "includes.h"
#include <pytalloc.h>
#include "librpc/rpc/pyrpc.h"
#include "librpc/rpc/pyrpc_util.h"
#include "autoconf/librpc/gen_ndr/ndr_cab.h"
#include "autoconf/librpc/gen_ndr/ndr_cab_c.h"

/*
 * These functions are here to ensure they can be optimized out by
 * the compiler based on the constant input values
 */

static inline unsigned long long ndr_sizeof2uintmax(size_t var_size)
{
	switch (var_size) {
	case 8:
		return UINT64_MAX;
	case 4:
		return UINT32_MAX;
	case 2:
		return UINT16_MAX;
	case 1:
		return UINT8_MAX;
	}

	return 0;
}

static inline long long ndr_sizeof2intmax(size_t var_size)
{
	switch (var_size) {
	case 8:
		return INT64_MAX;
	case 4:
		return INT32_MAX;
	case 2:
		return INT16_MAX;
	case 1:
		return INT8_MAX;
	}

	return 0;
}

static inline PyObject *ndr_PyLong_FromLongLong(long long v)
{
	if (v > LONG_MAX || v < LONG_MIN) {
		return PyLong_FromLongLong(v);
	} else {
		return PyInt_FromLong(v);
	}
}

static inline PyObject *ndr_PyLong_FromUnsignedLongLong(unsigned long long v)
{
	if (v > LONG_MAX) {
		return PyLong_FromUnsignedLongLong(v);
	} else {
		return PyInt_FromLong(v);
	}
}

#include "librpc/gen_ndr/misc.h"
static PyTypeObject CFHEADER_Type;
static PyTypeObject CFFOLDER_Type;
static PyTypeObject cf_date_Type;
static PyTypeObject cf_time_Type;
static PyTypeObject CFFILE_Type;
static PyTypeObject CFDATA_Type;
static PyTypeObject cab_file_Type;
static PyTypeObject cab_InterfaceType;
static PyTypeObject decode_cab_file_Type;

static PyTypeObject *BaseObject_Type;
static PyTypeObject *ClientConnection_Type;
static PyTypeObject *ndr_syntax_id_Type;

static PyObject *py_CFHEADER_get_signature(PyObject *obj, void *closure)
{
	struct CFHEADER *object = (struct CFHEADER *)pytalloc_get_ptr(obj);
	PyObject *py_signature;
	if (object->signature == NULL) {
		py_signature = Py_None;
		Py_INCREF(py_signature);
	} else {
		py_signature = PyUnicode_Decode(object->signature, strlen(object->signature), "utf-8", "ignore");
	}
	return py_signature;
}

static int py_CFHEADER_set_signature(PyObject *py_obj, PyObject *value, void *closure)
{
	struct CFHEADER *object = (struct CFHEADER *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->signature");
		return -1;
	}
	{
		const char *test_str;
		const char *talloc_str;
		PyObject *unicode = NULL;
		if (PyUnicode_Check(value)) {
			unicode = PyUnicode_AsEncodedString(value, "utf-8", "ignore");
			if (unicode == NULL) {
				PyErr_NoMemory();
				return -1;
			}
			test_str = PyBytes_AS_STRING(unicode);
		} else if (PyBytes_Check(value)) {
			test_str = PyBytes_AS_STRING(value);
		} else {
			PyErr_Format(PyExc_TypeError, "Expected string or unicode object, got %s", Py_TYPE(value)->tp_name);
			return -1;
		}
		talloc_str = talloc_strdup(pytalloc_get_mem_ctx(py_obj), test_str);
		if (unicode != NULL) {
			Py_DECREF(unicode);
		}
		if (talloc_str == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		object->signature = talloc_str;
	}
	return 0;
}

static PyObject *py_CFHEADER_get_reserved1(PyObject *obj, void *closure)
{
	struct CFHEADER *object = (struct CFHEADER *)pytalloc_get_ptr(obj);
	PyObject *py_reserved1;
	py_reserved1 = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->reserved1);
	return py_reserved1;
}

static int py_CFHEADER_set_reserved1(PyObject *py_obj, PyObject *value, void *closure)
{
	struct CFHEADER *object = (struct CFHEADER *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->reserved1");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->reserved1));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->reserved1 = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->reserved1 = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_CFHEADER_get_cbCabinet(PyObject *obj, void *closure)
{
	struct CFHEADER *object = (struct CFHEADER *)pytalloc_get_ptr(obj);
	PyObject *py_cbCabinet;
	py_cbCabinet = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->cbCabinet);
	return py_cbCabinet;
}

static int py_CFHEADER_set_cbCabinet(PyObject *py_obj, PyObject *value, void *closure)
{
	struct CFHEADER *object = (struct CFHEADER *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->cbCabinet");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->cbCabinet));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->cbCabinet = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->cbCabinet = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_CFHEADER_get_reserved2(PyObject *obj, void *closure)
{
	struct CFHEADER *object = (struct CFHEADER *)pytalloc_get_ptr(obj);
	PyObject *py_reserved2;
	py_reserved2 = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->reserved2);
	return py_reserved2;
}

static int py_CFHEADER_set_reserved2(PyObject *py_obj, PyObject *value, void *closure)
{
	struct CFHEADER *object = (struct CFHEADER *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->reserved2");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->reserved2));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->reserved2 = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->reserved2 = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_CFHEADER_get_coffFiles(PyObject *obj, void *closure)
{
	struct CFHEADER *object = (struct CFHEADER *)pytalloc_get_ptr(obj);
	PyObject *py_coffFiles;
	py_coffFiles = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->coffFiles);
	return py_coffFiles;
}

static int py_CFHEADER_set_coffFiles(PyObject *py_obj, PyObject *value, void *closure)
{
	struct CFHEADER *object = (struct CFHEADER *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->coffFiles");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->coffFiles));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->coffFiles = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->coffFiles = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_CFHEADER_get_reserved3(PyObject *obj, void *closure)
{
	struct CFHEADER *object = (struct CFHEADER *)pytalloc_get_ptr(obj);
	PyObject *py_reserved3;
	py_reserved3 = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->reserved3);
	return py_reserved3;
}

static int py_CFHEADER_set_reserved3(PyObject *py_obj, PyObject *value, void *closure)
{
	struct CFHEADER *object = (struct CFHEADER *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->reserved3");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->reserved3));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->reserved3 = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->reserved3 = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_CFHEADER_get_versionMinor(PyObject *obj, void *closure)
{
	struct CFHEADER *object = (struct CFHEADER *)pytalloc_get_ptr(obj);
	PyObject *py_versionMinor;
	py_versionMinor = PyInt_FromLong((uint16_t)object->versionMinor);
	return py_versionMinor;
}

static int py_CFHEADER_set_versionMinor(PyObject *py_obj, PyObject *value, void *closure)
{
	struct CFHEADER *object = (struct CFHEADER *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->versionMinor");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->versionMinor));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->versionMinor = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->versionMinor = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_CFHEADER_get_versionMajor(PyObject *obj, void *closure)
{
	struct CFHEADER *object = (struct CFHEADER *)pytalloc_get_ptr(obj);
	PyObject *py_versionMajor;
	py_versionMajor = PyInt_FromLong((uint16_t)object->versionMajor);
	return py_versionMajor;
}

static int py_CFHEADER_set_versionMajor(PyObject *py_obj, PyObject *value, void *closure)
{
	struct CFHEADER *object = (struct CFHEADER *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->versionMajor");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->versionMajor));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->versionMajor = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->versionMajor = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_CFHEADER_get_cFolders(PyObject *obj, void *closure)
{
	struct CFHEADER *object = (struct CFHEADER *)pytalloc_get_ptr(obj);
	PyObject *py_cFolders;
	py_cFolders = PyInt_FromLong((uint16_t)object->cFolders);
	return py_cFolders;
}

static int py_CFHEADER_set_cFolders(PyObject *py_obj, PyObject *value, void *closure)
{
	struct CFHEADER *object = (struct CFHEADER *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->cFolders");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->cFolders));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->cFolders = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->cFolders = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_CFHEADER_get_cFiles(PyObject *obj, void *closure)
{
	struct CFHEADER *object = (struct CFHEADER *)pytalloc_get_ptr(obj);
	PyObject *py_cFiles;
	py_cFiles = PyInt_FromLong((uint16_t)object->cFiles);
	return py_cFiles;
}

static int py_CFHEADER_set_cFiles(PyObject *py_obj, PyObject *value, void *closure)
{
	struct CFHEADER *object = (struct CFHEADER *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->cFiles");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->cFiles));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->cFiles = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->cFiles = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_CFHEADER_get_flags(PyObject *obj, void *closure)
{
	struct CFHEADER *object = (struct CFHEADER *)pytalloc_get_ptr(obj);
	PyObject *py_flags;
	py_flags = PyInt_FromLong((uint16_t)object->flags);
	return py_flags;
}

static int py_CFHEADER_set_flags(PyObject *py_obj, PyObject *value, void *closure)
{
	struct CFHEADER *object = (struct CFHEADER *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->flags");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->flags));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->flags = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->flags = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_CFHEADER_get_setID(PyObject *obj, void *closure)
{
	struct CFHEADER *object = (struct CFHEADER *)pytalloc_get_ptr(obj);
	PyObject *py_setID;
	py_setID = PyInt_FromLong((uint16_t)object->setID);
	return py_setID;
}

static int py_CFHEADER_set_setID(PyObject *py_obj, PyObject *value, void *closure)
{
	struct CFHEADER *object = (struct CFHEADER *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->setID");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->setID));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->setID = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->setID = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_CFHEADER_get_iCabinet(PyObject *obj, void *closure)
{
	struct CFHEADER *object = (struct CFHEADER *)pytalloc_get_ptr(obj);
	PyObject *py_iCabinet;
	py_iCabinet = PyInt_FromLong((uint16_t)object->iCabinet);
	return py_iCabinet;
}

static int py_CFHEADER_set_iCabinet(PyObject *py_obj, PyObject *value, void *closure)
{
	struct CFHEADER *object = (struct CFHEADER *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->iCabinet");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->iCabinet));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->iCabinet = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->iCabinet = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyGetSetDef py_CFHEADER_getsetters[] = {
	{
		.name = discard_const_p(char, "signature"),
		.get = py_CFHEADER_get_signature,
		.set = py_CFHEADER_set_signature,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint8")
	},
	{
		.name = discard_const_p(char, "reserved1"),
		.get = py_CFHEADER_get_reserved1,
		.set = py_CFHEADER_set_reserved1,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "cbCabinet"),
		.get = py_CFHEADER_get_cbCabinet,
		.set = py_CFHEADER_set_cbCabinet,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "reserved2"),
		.get = py_CFHEADER_get_reserved2,
		.set = py_CFHEADER_set_reserved2,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "coffFiles"),
		.get = py_CFHEADER_get_coffFiles,
		.set = py_CFHEADER_set_coffFiles,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "reserved3"),
		.get = py_CFHEADER_get_reserved3,
		.set = py_CFHEADER_set_reserved3,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "versionMinor"),
		.get = py_CFHEADER_get_versionMinor,
		.set = py_CFHEADER_set_versionMinor,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint8")
	},
	{
		.name = discard_const_p(char, "versionMajor"),
		.get = py_CFHEADER_get_versionMajor,
		.set = py_CFHEADER_set_versionMajor,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint8")
	},
	{
		.name = discard_const_p(char, "cFolders"),
		.get = py_CFHEADER_get_cFolders,
		.set = py_CFHEADER_set_cFolders,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint16")
	},
	{
		.name = discard_const_p(char, "cFiles"),
		.get = py_CFHEADER_get_cFiles,
		.set = py_CFHEADER_set_cFiles,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint16")
	},
	{
		.name = discard_const_p(char, "flags"),
		.get = py_CFHEADER_get_flags,
		.set = py_CFHEADER_set_flags,
		.doc = discard_const_p(char, "PIDL-generated element of base type cf_flags")
	},
	{
		.name = discard_const_p(char, "setID"),
		.get = py_CFHEADER_get_setID,
		.set = py_CFHEADER_set_setID,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint16")
	},
	{
		.name = discard_const_p(char, "iCabinet"),
		.get = py_CFHEADER_get_iCabinet,
		.set = py_CFHEADER_set_iCabinet,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint16")
	},
	{ .name = NULL }
};

static PyObject *py_CFHEADER_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct CFHEADER, type);
}

static PyObject *py_CFHEADER_ndr_pack(PyObject *py_obj)
{
	struct CFHEADER *object = (struct CFHEADER *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;
	TALLOC_CTX *tmp_ctx = talloc_new(pytalloc_get_mem_ctx(py_obj));
	if (tmp_ctx == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}
	err = ndr_push_struct_blob(&blob, tmp_ctx, object, (ndr_push_flags_fn_t)ndr_push_CFHEADER);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(tmp_ctx);
		PyErr_SetNdrError(err);
		return NULL;
	}

	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(tmp_ctx);
	return ret;
}

static PyObject *py_CFHEADER_ndr_unpack(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	struct CFHEADER *object = (struct CFHEADER *)pytalloc_get_ptr(py_obj);
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	enum ndr_err_code err;
	const char * const kwnames[] = { "data_blob", "allow_remaining", NULL };
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|O:__ndr_unpack__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	if (allow_remaining) {
		err = ndr_pull_struct_blob(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_CFHEADER);
	} else {
		err = ndr_pull_struct_blob_all(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_CFHEADER);
	}
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		PyErr_SetNdrError(err);
		return NULL;
	}

	Py_RETURN_NONE;
}

static PyObject *py_CFHEADER_ndr_print(PyObject *py_obj)
{
	struct CFHEADER *object = (struct CFHEADER *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	retstr = ndr_print_struct_string(pytalloc_get_mem_ctx(py_obj), (ndr_print_fn_t)ndr_print_CFHEADER, "CFHEADER", object);
	ret = PyStr_FromString(retstr);
	talloc_free(retstr);

	return ret;
}

static PyMethodDef py_CFHEADER_methods[] = {
	{ "__ndr_pack__", (PyCFunction)py_CFHEADER_ndr_pack, METH_NOARGS, "S.ndr_pack(object) -> blob\nNDR pack" },
	{ "__ndr_unpack__", (PyCFunction)py_CFHEADER_ndr_unpack, METH_VARARGS|METH_KEYWORDS, "S.ndr_unpack(class, blob, allow_remaining=False) -> None\nNDR unpack" },
	{ "__ndr_print__", (PyCFunction)py_CFHEADER_ndr_print, METH_NOARGS, "S.ndr_print(object) -> None\nNDR print" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject CFHEADER_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "cab.CFHEADER",
	.tp_getset = py_CFHEADER_getsetters,
	.tp_methods = py_CFHEADER_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_CFHEADER_new,
};


static PyObject *py_CFFOLDER_get_coffCabStart(PyObject *obj, void *closure)
{
	struct CFFOLDER *object = (struct CFFOLDER *)pytalloc_get_ptr(obj);
	PyObject *py_coffCabStart;
	py_coffCabStart = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->coffCabStart);
	return py_coffCabStart;
}

static int py_CFFOLDER_set_coffCabStart(PyObject *py_obj, PyObject *value, void *closure)
{
	struct CFFOLDER *object = (struct CFFOLDER *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->coffCabStart");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->coffCabStart));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->coffCabStart = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->coffCabStart = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_CFFOLDER_get_cCFData(PyObject *obj, void *closure)
{
	struct CFFOLDER *object = (struct CFFOLDER *)pytalloc_get_ptr(obj);
	PyObject *py_cCFData;
	py_cCFData = PyInt_FromLong((uint16_t)object->cCFData);
	return py_cCFData;
}

static int py_CFFOLDER_set_cCFData(PyObject *py_obj, PyObject *value, void *closure)
{
	struct CFFOLDER *object = (struct CFFOLDER *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->cCFData");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->cCFData));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->cCFData = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->cCFData = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_CFFOLDER_get_typeCompress(PyObject *obj, void *closure)
{
	struct CFFOLDER *object = (struct CFFOLDER *)pytalloc_get_ptr(obj);
	PyObject *py_typeCompress;
	py_typeCompress = PyInt_FromLong((uint16_t)object->typeCompress);
	return py_typeCompress;
}

static int py_CFFOLDER_set_typeCompress(PyObject *py_obj, PyObject *value, void *closure)
{
	struct CFFOLDER *object = (struct CFFOLDER *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->typeCompress");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->typeCompress));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->typeCompress = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->typeCompress = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyGetSetDef py_CFFOLDER_getsetters[] = {
	{
		.name = discard_const_p(char, "coffCabStart"),
		.get = py_CFFOLDER_get_coffCabStart,
		.set = py_CFFOLDER_set_coffCabStart,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "cCFData"),
		.get = py_CFFOLDER_get_cCFData,
		.set = py_CFFOLDER_set_cCFData,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint16")
	},
	{
		.name = discard_const_p(char, "typeCompress"),
		.get = py_CFFOLDER_get_typeCompress,
		.set = py_CFFOLDER_set_typeCompress,
		.doc = discard_const_p(char, "PIDL-generated element of base type cf_compress_type")
	},
	{ .name = NULL }
};

static PyObject *py_CFFOLDER_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct CFFOLDER, type);
}

static PyObject *py_CFFOLDER_ndr_pack(PyObject *py_obj)
{
	struct CFFOLDER *object = (struct CFFOLDER *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;
	TALLOC_CTX *tmp_ctx = talloc_new(pytalloc_get_mem_ctx(py_obj));
	if (tmp_ctx == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}
	err = ndr_push_struct_blob(&blob, tmp_ctx, object, (ndr_push_flags_fn_t)ndr_push_CFFOLDER);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(tmp_ctx);
		PyErr_SetNdrError(err);
		return NULL;
	}

	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(tmp_ctx);
	return ret;
}

static PyObject *py_CFFOLDER_ndr_unpack(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	struct CFFOLDER *object = (struct CFFOLDER *)pytalloc_get_ptr(py_obj);
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	enum ndr_err_code err;
	const char * const kwnames[] = { "data_blob", "allow_remaining", NULL };
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|O:__ndr_unpack__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	if (allow_remaining) {
		err = ndr_pull_struct_blob(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_CFFOLDER);
	} else {
		err = ndr_pull_struct_blob_all(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_CFFOLDER);
	}
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		PyErr_SetNdrError(err);
		return NULL;
	}

	Py_RETURN_NONE;
}

static PyObject *py_CFFOLDER_ndr_print(PyObject *py_obj)
{
	struct CFFOLDER *object = (struct CFFOLDER *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	retstr = ndr_print_struct_string(pytalloc_get_mem_ctx(py_obj), (ndr_print_fn_t)ndr_print_CFFOLDER, "CFFOLDER", object);
	ret = PyStr_FromString(retstr);
	talloc_free(retstr);

	return ret;
}

static PyMethodDef py_CFFOLDER_methods[] = {
	{ "__ndr_pack__", (PyCFunction)py_CFFOLDER_ndr_pack, METH_NOARGS, "S.ndr_pack(object) -> blob\nNDR pack" },
	{ "__ndr_unpack__", (PyCFunction)py_CFFOLDER_ndr_unpack, METH_VARARGS|METH_KEYWORDS, "S.ndr_unpack(class, blob, allow_remaining=False) -> None\nNDR unpack" },
	{ "__ndr_print__", (PyCFunction)py_CFFOLDER_ndr_print, METH_NOARGS, "S.ndr_print(object) -> None\nNDR print" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject CFFOLDER_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "cab.CFFOLDER",
	.tp_getset = py_CFFOLDER_getsetters,
	.tp_methods = py_CFFOLDER_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_CFFOLDER_new,
};


static PyObject *py_cf_date_get_date(PyObject *obj, void *closure)
{
	struct cf_date *object = (struct cf_date *)pytalloc_get_ptr(obj);
	PyObject *py_date;
	py_date = PyInt_FromLong((uint16_t)object->date);
	return py_date;
}

static int py_cf_date_set_date(PyObject *py_obj, PyObject *value, void *closure)
{
	struct cf_date *object = (struct cf_date *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->date");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->date));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->date = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->date = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyGetSetDef py_cf_date_getsetters[] = {
	{
		.name = discard_const_p(char, "date"),
		.get = py_cf_date_get_date,
		.set = py_cf_date_set_date,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint16")
	},
	{ .name = NULL }
};

static PyObject *py_cf_date_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct cf_date, type);
}


static PyTypeObject cf_date_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "cab.cf_date",
	.tp_getset = py_cf_date_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_cf_date_new,
};


static PyObject *py_cf_time_get_time(PyObject *obj, void *closure)
{
	struct cf_time *object = (struct cf_time *)pytalloc_get_ptr(obj);
	PyObject *py_time;
	py_time = PyInt_FromLong((uint16_t)object->time);
	return py_time;
}

static int py_cf_time_set_time(PyObject *py_obj, PyObject *value, void *closure)
{
	struct cf_time *object = (struct cf_time *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->time");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->time));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->time = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->time = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyGetSetDef py_cf_time_getsetters[] = {
	{
		.name = discard_const_p(char, "time"),
		.get = py_cf_time_get_time,
		.set = py_cf_time_set_time,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint16")
	},
	{ .name = NULL }
};

static PyObject *py_cf_time_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct cf_time, type);
}


static PyTypeObject cf_time_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "cab.cf_time",
	.tp_getset = py_cf_time_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_cf_time_new,
};


static PyObject *py_CFFILE_get_cbFile(PyObject *obj, void *closure)
{
	struct CFFILE *object = (struct CFFILE *)pytalloc_get_ptr(obj);
	PyObject *py_cbFile;
	py_cbFile = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->cbFile);
	return py_cbFile;
}

static int py_CFFILE_set_cbFile(PyObject *py_obj, PyObject *value, void *closure)
{
	struct CFFILE *object = (struct CFFILE *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->cbFile");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->cbFile));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->cbFile = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->cbFile = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_CFFILE_get_uoffFolderStart(PyObject *obj, void *closure)
{
	struct CFFILE *object = (struct CFFILE *)pytalloc_get_ptr(obj);
	PyObject *py_uoffFolderStart;
	py_uoffFolderStart = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->uoffFolderStart);
	return py_uoffFolderStart;
}

static int py_CFFILE_set_uoffFolderStart(PyObject *py_obj, PyObject *value, void *closure)
{
	struct CFFILE *object = (struct CFFILE *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->uoffFolderStart");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->uoffFolderStart));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->uoffFolderStart = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->uoffFolderStart = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_CFFILE_get_iFolder(PyObject *obj, void *closure)
{
	struct CFFILE *object = (struct CFFILE *)pytalloc_get_ptr(obj);
	PyObject *py_iFolder;
	py_iFolder = PyInt_FromLong((uint16_t)object->iFolder);
	return py_iFolder;
}

static int py_CFFILE_set_iFolder(PyObject *py_obj, PyObject *value, void *closure)
{
	struct CFFILE *object = (struct CFFILE *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->iFolder");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->iFolder));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->iFolder = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->iFolder = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_CFFILE_get_date(PyObject *obj, void *closure)
{
	struct CFFILE *object = (struct CFFILE *)pytalloc_get_ptr(obj);
	PyObject *py_date;
	py_date = pytalloc_reference_ex(&cf_date_Type, pytalloc_get_mem_ctx(obj), &object->date);
	return py_date;
}

static int py_CFFILE_set_date(PyObject *py_obj, PyObject *value, void *closure)
{
	struct CFFILE *object = (struct CFFILE *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->date");
		return -1;
	}
	PY_CHECK_TYPE(&cf_date_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->date = *(struct cf_date *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_CFFILE_get_time(PyObject *obj, void *closure)
{
	struct CFFILE *object = (struct CFFILE *)pytalloc_get_ptr(obj);
	PyObject *py_time;
	py_time = pytalloc_reference_ex(&cf_time_Type, pytalloc_get_mem_ctx(obj), &object->time);
	return py_time;
}

static int py_CFFILE_set_time(PyObject *py_obj, PyObject *value, void *closure)
{
	struct CFFILE *object = (struct CFFILE *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->time");
		return -1;
	}
	PY_CHECK_TYPE(&cf_time_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->time = *(struct cf_time *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_CFFILE_get_attribs(PyObject *obj, void *closure)
{
	struct CFFILE *object = (struct CFFILE *)pytalloc_get_ptr(obj);
	PyObject *py_attribs;
	py_attribs = PyInt_FromLong((uint16_t)object->attribs);
	return py_attribs;
}

static int py_CFFILE_set_attribs(PyObject *py_obj, PyObject *value, void *closure)
{
	struct CFFILE *object = (struct CFFILE *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->attribs");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->attribs));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->attribs = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->attribs = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_CFFILE_get_szName(PyObject *obj, void *closure)
{
	struct CFFILE *object = (struct CFFILE *)pytalloc_get_ptr(obj);
	PyObject *py_szName;
	py_szName = PyString_FromStringOrNULL(object->szName);
	return py_szName;
}

static int py_CFFILE_set_szName(PyObject *py_obj, PyObject *value, void *closure)
{
	struct CFFILE *object = (struct CFFILE *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->szName");
		return -1;
	}
	{
		const char *test_str;
		const char *talloc_str;
		PyObject *unicode = NULL;
		if (PyUnicode_Check(value)) {
			unicode = PyUnicode_AsEncodedString(value, "utf-8", "ignore");
			if (unicode == NULL) {
				PyErr_NoMemory();
				return -1;
			}
			test_str = PyBytes_AS_STRING(unicode);
		} else if (PyBytes_Check(value)) {
			test_str = PyBytes_AS_STRING(value);
		} else {
			PyErr_Format(PyExc_TypeError, "Expected string or unicode object, got %s", Py_TYPE(value)->tp_name);
			return -1;
		}
		talloc_str = talloc_strdup(pytalloc_get_mem_ctx(py_obj), test_str);
		if (unicode != NULL) {
			Py_DECREF(unicode);
		}
		if (talloc_str == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		object->szName = talloc_str;
	}
	return 0;
}

static PyGetSetDef py_CFFILE_getsetters[] = {
	{
		.name = discard_const_p(char, "cbFile"),
		.get = py_CFFILE_get_cbFile,
		.set = py_CFFILE_set_cbFile,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "uoffFolderStart"),
		.get = py_CFFILE_get_uoffFolderStart,
		.set = py_CFFILE_set_uoffFolderStart,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "iFolder"),
		.get = py_CFFILE_get_iFolder,
		.set = py_CFFILE_set_iFolder,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint16")
	},
	{
		.name = discard_const_p(char, "date"),
		.get = py_CFFILE_get_date,
		.set = py_CFFILE_set_date,
		.doc = discard_const_p(char, "PIDL-generated element of base type cf_date")
	},
	{
		.name = discard_const_p(char, "time"),
		.get = py_CFFILE_get_time,
		.set = py_CFFILE_set_time,
		.doc = discard_const_p(char, "PIDL-generated element of base type cf_time")
	},
	{
		.name = discard_const_p(char, "attribs"),
		.get = py_CFFILE_get_attribs,
		.set = py_CFFILE_set_attribs,
		.doc = discard_const_p(char, "PIDL-generated element of base type cf_attributes")
	},
	{
		.name = discard_const_p(char, "szName"),
		.get = py_CFFILE_get_szName,
		.set = py_CFFILE_set_szName,
		.doc = discard_const_p(char, "PIDL-generated element of base type string")
	},
	{ .name = NULL }
};

static PyObject *py_CFFILE_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct CFFILE, type);
}

static PyObject *py_CFFILE_ndr_pack(PyObject *py_obj)
{
	struct CFFILE *object = (struct CFFILE *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;
	TALLOC_CTX *tmp_ctx = talloc_new(pytalloc_get_mem_ctx(py_obj));
	if (tmp_ctx == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}
	err = ndr_push_struct_blob(&blob, tmp_ctx, object, (ndr_push_flags_fn_t)ndr_push_CFFILE);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(tmp_ctx);
		PyErr_SetNdrError(err);
		return NULL;
	}

	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(tmp_ctx);
	return ret;
}

static PyObject *py_CFFILE_ndr_unpack(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	struct CFFILE *object = (struct CFFILE *)pytalloc_get_ptr(py_obj);
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	enum ndr_err_code err;
	const char * const kwnames[] = { "data_blob", "allow_remaining", NULL };
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|O:__ndr_unpack__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	if (allow_remaining) {
		err = ndr_pull_struct_blob(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_CFFILE);
	} else {
		err = ndr_pull_struct_blob_all(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_CFFILE);
	}
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		PyErr_SetNdrError(err);
		return NULL;
	}

	Py_RETURN_NONE;
}

static PyObject *py_CFFILE_ndr_print(PyObject *py_obj)
{
	struct CFFILE *object = (struct CFFILE *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	retstr = ndr_print_struct_string(pytalloc_get_mem_ctx(py_obj), (ndr_print_fn_t)ndr_print_CFFILE, "CFFILE", object);
	ret = PyStr_FromString(retstr);
	talloc_free(retstr);

	return ret;
}

static PyMethodDef py_CFFILE_methods[] = {
	{ "__ndr_pack__", (PyCFunction)py_CFFILE_ndr_pack, METH_NOARGS, "S.ndr_pack(object) -> blob\nNDR pack" },
	{ "__ndr_unpack__", (PyCFunction)py_CFFILE_ndr_unpack, METH_VARARGS|METH_KEYWORDS, "S.ndr_unpack(class, blob, allow_remaining=False) -> None\nNDR unpack" },
	{ "__ndr_print__", (PyCFunction)py_CFFILE_ndr_print, METH_NOARGS, "S.ndr_print(object) -> None\nNDR print" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject CFFILE_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "cab.CFFILE",
	.tp_getset = py_CFFILE_getsetters,
	.tp_methods = py_CFFILE_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_CFFILE_new,
};


static PyObject *py_CFDATA_get_csum(PyObject *obj, void *closure)
{
	struct CFDATA *object = (struct CFDATA *)pytalloc_get_ptr(obj);
	PyObject *py_csum;
	py_csum = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->csum);
	return py_csum;
}

static int py_CFDATA_set_csum(PyObject *py_obj, PyObject *value, void *closure)
{
	struct CFDATA *object = (struct CFDATA *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->csum");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->csum));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->csum = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->csum = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_CFDATA_get_cbData(PyObject *obj, void *closure)
{
	struct CFDATA *object = (struct CFDATA *)pytalloc_get_ptr(obj);
	PyObject *py_cbData;
	py_cbData = PyInt_FromLong((uint16_t)object->cbData);
	return py_cbData;
}

static int py_CFDATA_set_cbData(PyObject *py_obj, PyObject *value, void *closure)
{
	struct CFDATA *object = (struct CFDATA *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->cbData");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->cbData));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->cbData = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->cbData = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_CFDATA_get_cbUncomp(PyObject *obj, void *closure)
{
	struct CFDATA *object = (struct CFDATA *)pytalloc_get_ptr(obj);
	PyObject *py_cbUncomp;
	py_cbUncomp = PyInt_FromLong((uint16_t)object->cbUncomp);
	return py_cbUncomp;
}

static int py_CFDATA_set_cbUncomp(PyObject *py_obj, PyObject *value, void *closure)
{
	struct CFDATA *object = (struct CFDATA *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->cbUncomp");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->cbUncomp));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->cbUncomp = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->cbUncomp = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_CFDATA_get_ab(PyObject *obj, void *closure)
{
	struct CFDATA *object = (struct CFDATA *)pytalloc_get_ptr(obj);
	PyObject *py_ab;
	py_ab = PyList_New(object->cbData);
	if (py_ab == NULL) {
		return NULL;
	}
	{
		int ab_cntr_0;
		for (ab_cntr_0 = 0; ab_cntr_0 < (object->cbData); ab_cntr_0++) {
			PyObject *py_ab_0;
			py_ab_0 = PyInt_FromLong((uint16_t)object->ab[ab_cntr_0]);
			PyList_SetItem(py_ab, ab_cntr_0, py_ab_0);
		}
	}
	return py_ab;
}

static int py_CFDATA_set_ab(PyObject *py_obj, PyObject *value, void *closure)
{
	struct CFDATA *object = (struct CFDATA *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->ab");
		return -1;
	}
	PY_CHECK_TYPE(&PyList_Type, value, return -1;);
	{
		int ab_cntr_0;
		object->ab = talloc_array_ptrtype(pytalloc_get_mem_ctx(py_obj), object->ab, PyList_GET_SIZE(value));
		if (!object->ab) { return -1;; }
		talloc_set_name_const(object->ab, "ARRAY: object->ab");
		for (ab_cntr_0 = 0; ab_cntr_0 < PyList_GET_SIZE(value); ab_cntr_0++) {
			if (PyList_GET_ITEM(value, ab_cntr_0) == NULL) {
				PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->ab[ab_cntr_0]");
				return -1;
			}
			{
				const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->ab[ab_cntr_0]));
				if (PyLong_Check(PyList_GET_ITEM(value, ab_cntr_0))) {
					unsigned long long test_var;
					test_var = PyLong_AsUnsignedLongLong(PyList_GET_ITEM(value, ab_cntr_0));
					if (PyErr_Occurred() != NULL) {
						return -1;
					}
					if (test_var > uint_max) {
						PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
						  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
						return -1;
					}
					object->ab[ab_cntr_0] = test_var;
				} else if (PyInt_Check(PyList_GET_ITEM(value, ab_cntr_0))) {
					long test_var;
					test_var = PyInt_AsLong(PyList_GET_ITEM(value, ab_cntr_0));
					if (test_var < 0 || test_var > uint_max) {
						PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
						  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
						return -1;
					}
					object->ab[ab_cntr_0] = test_var;
				} else {
					PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
					  PyInt_Type.tp_name, PyLong_Type.tp_name);
					return -1;
				}
			}
		}
	}
	return 0;
}

static PyGetSetDef py_CFDATA_getsetters[] = {
	{
		.name = discard_const_p(char, "csum"),
		.get = py_CFDATA_get_csum,
		.set = py_CFDATA_set_csum,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "cbData"),
		.get = py_CFDATA_get_cbData,
		.set = py_CFDATA_set_cbData,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint16")
	},
	{
		.name = discard_const_p(char, "cbUncomp"),
		.get = py_CFDATA_get_cbUncomp,
		.set = py_CFDATA_set_cbUncomp,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint16")
	},
	{
		.name = discard_const_p(char, "ab"),
		.get = py_CFDATA_get_ab,
		.set = py_CFDATA_set_ab,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint8")
	},
	{ .name = NULL }
};

static PyObject *py_CFDATA_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct CFDATA, type);
}

static PyObject *py_CFDATA_ndr_pack(PyObject *py_obj)
{
	struct CFDATA *object = (struct CFDATA *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;
	TALLOC_CTX *tmp_ctx = talloc_new(pytalloc_get_mem_ctx(py_obj));
	if (tmp_ctx == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}
	err = ndr_push_struct_blob(&blob, tmp_ctx, object, (ndr_push_flags_fn_t)ndr_push_CFDATA);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(tmp_ctx);
		PyErr_SetNdrError(err);
		return NULL;
	}

	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(tmp_ctx);
	return ret;
}

static PyObject *py_CFDATA_ndr_unpack(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	struct CFDATA *object = (struct CFDATA *)pytalloc_get_ptr(py_obj);
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	enum ndr_err_code err;
	const char * const kwnames[] = { "data_blob", "allow_remaining", NULL };
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|O:__ndr_unpack__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	if (allow_remaining) {
		err = ndr_pull_struct_blob(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_CFDATA);
	} else {
		err = ndr_pull_struct_blob_all(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_CFDATA);
	}
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		PyErr_SetNdrError(err);
		return NULL;
	}

	Py_RETURN_NONE;
}

static PyObject *py_CFDATA_ndr_print(PyObject *py_obj)
{
	struct CFDATA *object = (struct CFDATA *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	retstr = ndr_print_struct_string(pytalloc_get_mem_ctx(py_obj), (ndr_print_fn_t)ndr_print_CFDATA, "CFDATA", object);
	ret = PyStr_FromString(retstr);
	talloc_free(retstr);

	return ret;
}

static PyMethodDef py_CFDATA_methods[] = {
	{ "__ndr_pack__", (PyCFunction)py_CFDATA_ndr_pack, METH_NOARGS, "S.ndr_pack(object) -> blob\nNDR pack" },
	{ "__ndr_unpack__", (PyCFunction)py_CFDATA_ndr_unpack, METH_VARARGS|METH_KEYWORDS, "S.ndr_unpack(class, blob, allow_remaining=False) -> None\nNDR unpack" },
	{ "__ndr_print__", (PyCFunction)py_CFDATA_ndr_print, METH_NOARGS, "S.ndr_print(object) -> None\nNDR print" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject CFDATA_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "cab.CFDATA",
	.tp_getset = py_CFDATA_getsetters,
	.tp_methods = py_CFDATA_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_CFDATA_new,
};


static PyObject *py_cab_file_get_cfheader(PyObject *obj, void *closure)
{
	struct cab_file *object = (struct cab_file *)pytalloc_get_ptr(obj);
	PyObject *py_cfheader;
	py_cfheader = pytalloc_reference_ex(&CFHEADER_Type, pytalloc_get_mem_ctx(obj), &object->cfheader);
	return py_cfheader;
}

static int py_cab_file_set_cfheader(PyObject *py_obj, PyObject *value, void *closure)
{
	struct cab_file *object = (struct cab_file *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->cfheader");
		return -1;
	}
	PY_CHECK_TYPE(&CFHEADER_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->cfheader = *(struct CFHEADER *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_cab_file_get_cffolders(PyObject *obj, void *closure)
{
	struct cab_file *object = (struct cab_file *)pytalloc_get_ptr(obj);
	PyObject *py_cffolders;
	py_cffolders = PyList_New(object->cfheader.cFolders);
	if (py_cffolders == NULL) {
		return NULL;
	}
	{
		int cffolders_cntr_0;
		for (cffolders_cntr_0 = 0; cffolders_cntr_0 < (object->cfheader.cFolders); cffolders_cntr_0++) {
			PyObject *py_cffolders_0;
			py_cffolders_0 = pytalloc_reference_ex(&CFFOLDER_Type, object->cffolders, &object->cffolders[cffolders_cntr_0]);
			PyList_SetItem(py_cffolders, cffolders_cntr_0, py_cffolders_0);
		}
	}
	return py_cffolders;
}

static int py_cab_file_set_cffolders(PyObject *py_obj, PyObject *value, void *closure)
{
	struct cab_file *object = (struct cab_file *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->cffolders");
		return -1;
	}
	PY_CHECK_TYPE(&PyList_Type, value, return -1;);
	{
		int cffolders_cntr_0;
		object->cffolders = talloc_array_ptrtype(pytalloc_get_mem_ctx(py_obj), object->cffolders, PyList_GET_SIZE(value));
		if (!object->cffolders) { return -1;; }
		talloc_set_name_const(object->cffolders, "ARRAY: object->cffolders");
		for (cffolders_cntr_0 = 0; cffolders_cntr_0 < PyList_GET_SIZE(value); cffolders_cntr_0++) {
			if (PyList_GET_ITEM(value, cffolders_cntr_0) == NULL) {
				PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->cffolders[cffolders_cntr_0]");
				return -1;
			}
			PY_CHECK_TYPE(&CFFOLDER_Type, PyList_GET_ITEM(value, cffolders_cntr_0), return -1;);
			if (talloc_reference(object->cffolders, pytalloc_get_mem_ctx(PyList_GET_ITEM(value, cffolders_cntr_0))) == NULL) {
				PyErr_NoMemory();
				return -1;
			}
			object->cffolders[cffolders_cntr_0] = *(struct CFFOLDER *)pytalloc_get_ptr(PyList_GET_ITEM(value, cffolders_cntr_0));
		}
	}
	return 0;
}

static PyObject *py_cab_file_get_cffiles(PyObject *obj, void *closure)
{
	struct cab_file *object = (struct cab_file *)pytalloc_get_ptr(obj);
	PyObject *py_cffiles;
	py_cffiles = PyList_New(object->cfheader.cFiles);
	if (py_cffiles == NULL) {
		return NULL;
	}
	{
		int cffiles_cntr_0;
		for (cffiles_cntr_0 = 0; cffiles_cntr_0 < (object->cfheader.cFiles); cffiles_cntr_0++) {
			PyObject *py_cffiles_0;
			py_cffiles_0 = pytalloc_reference_ex(&CFFILE_Type, object->cffiles, &object->cffiles[cffiles_cntr_0]);
			PyList_SetItem(py_cffiles, cffiles_cntr_0, py_cffiles_0);
		}
	}
	return py_cffiles;
}

static int py_cab_file_set_cffiles(PyObject *py_obj, PyObject *value, void *closure)
{
	struct cab_file *object = (struct cab_file *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->cffiles");
		return -1;
	}
	PY_CHECK_TYPE(&PyList_Type, value, return -1;);
	{
		int cffiles_cntr_0;
		object->cffiles = talloc_array_ptrtype(pytalloc_get_mem_ctx(py_obj), object->cffiles, PyList_GET_SIZE(value));
		if (!object->cffiles) { return -1;; }
		talloc_set_name_const(object->cffiles, "ARRAY: object->cffiles");
		for (cffiles_cntr_0 = 0; cffiles_cntr_0 < PyList_GET_SIZE(value); cffiles_cntr_0++) {
			if (PyList_GET_ITEM(value, cffiles_cntr_0) == NULL) {
				PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->cffiles[cffiles_cntr_0]");
				return -1;
			}
			PY_CHECK_TYPE(&CFFILE_Type, PyList_GET_ITEM(value, cffiles_cntr_0), return -1;);
			if (talloc_reference(object->cffiles, pytalloc_get_mem_ctx(PyList_GET_ITEM(value, cffiles_cntr_0))) == NULL) {
				PyErr_NoMemory();
				return -1;
			}
			object->cffiles[cffiles_cntr_0] = *(struct CFFILE *)pytalloc_get_ptr(PyList_GET_ITEM(value, cffiles_cntr_0));
		}
	}
	return 0;
}

static PyObject *py_cab_file_get_cfdata_count(PyObject *obj, void *closure)
{
	struct cab_file *object = (struct cab_file *)pytalloc_get_ptr(obj);
	PyObject *py_cfdata_count;
	py_cfdata_count = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->cfdata_count);
	return py_cfdata_count;
}

static int py_cab_file_set_cfdata_count(PyObject *py_obj, PyObject *value, void *closure)
{
	struct cab_file *object = (struct cab_file *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->cfdata_count");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->cfdata_count));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->cfdata_count = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->cfdata_count = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_cab_file_get_cfdata(PyObject *obj, void *closure)
{
	struct cab_file *object = (struct cab_file *)pytalloc_get_ptr(obj);
	PyObject *py_cfdata;
	py_cfdata = PyList_New(object->cfdata_count);
	if (py_cfdata == NULL) {
		return NULL;
	}
	{
		int cfdata_cntr_0;
		for (cfdata_cntr_0 = 0; cfdata_cntr_0 < (object->cfdata_count); cfdata_cntr_0++) {
			PyObject *py_cfdata_0;
			py_cfdata_0 = pytalloc_reference_ex(&CFDATA_Type, object->cfdata, &object->cfdata[cfdata_cntr_0]);
			PyList_SetItem(py_cfdata, cfdata_cntr_0, py_cfdata_0);
		}
	}
	return py_cfdata;
}

static int py_cab_file_set_cfdata(PyObject *py_obj, PyObject *value, void *closure)
{
	struct cab_file *object = (struct cab_file *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->cfdata");
		return -1;
	}
	PY_CHECK_TYPE(&PyList_Type, value, return -1;);
	{
		int cfdata_cntr_0;
		object->cfdata = talloc_array_ptrtype(pytalloc_get_mem_ctx(py_obj), object->cfdata, PyList_GET_SIZE(value));
		if (!object->cfdata) { return -1;; }
		talloc_set_name_const(object->cfdata, "ARRAY: object->cfdata");
		for (cfdata_cntr_0 = 0; cfdata_cntr_0 < PyList_GET_SIZE(value); cfdata_cntr_0++) {
			if (PyList_GET_ITEM(value, cfdata_cntr_0) == NULL) {
				PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->cfdata[cfdata_cntr_0]");
				return -1;
			}
			PY_CHECK_TYPE(&CFDATA_Type, PyList_GET_ITEM(value, cfdata_cntr_0), return -1;);
			if (talloc_reference(object->cfdata, pytalloc_get_mem_ctx(PyList_GET_ITEM(value, cfdata_cntr_0))) == NULL) {
				PyErr_NoMemory();
				return -1;
			}
			object->cfdata[cfdata_cntr_0] = *(struct CFDATA *)pytalloc_get_ptr(PyList_GET_ITEM(value, cfdata_cntr_0));
		}
	}
	return 0;
}

static PyGetSetDef py_cab_file_getsetters[] = {
	{
		.name = discard_const_p(char, "cfheader"),
		.get = py_cab_file_get_cfheader,
		.set = py_cab_file_set_cfheader,
		.doc = discard_const_p(char, "PIDL-generated element of base type CFHEADER")
	},
	{
		.name = discard_const_p(char, "cffolders"),
		.get = py_cab_file_get_cffolders,
		.set = py_cab_file_set_cffolders,
		.doc = discard_const_p(char, "PIDL-generated element of base type CFFOLDER")
	},
	{
		.name = discard_const_p(char, "cffiles"),
		.get = py_cab_file_get_cffiles,
		.set = py_cab_file_set_cffiles,
		.doc = discard_const_p(char, "PIDL-generated element of base type CFFILE")
	},
	{
		.name = discard_const_p(char, "cfdata_count"),
		.get = py_cab_file_get_cfdata_count,
		.set = py_cab_file_set_cfdata_count,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "cfdata"),
		.get = py_cab_file_get_cfdata,
		.set = py_cab_file_set_cfdata,
		.doc = discard_const_p(char, "PIDL-generated element of base type CFDATA")
	},
	{ .name = NULL }
};

static PyObject *py_cab_file_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct cab_file, type);
}

static PyObject *py_cab_file_ndr_pack(PyObject *py_obj)
{
	struct cab_file *object = (struct cab_file *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;
	TALLOC_CTX *tmp_ctx = talloc_new(pytalloc_get_mem_ctx(py_obj));
	if (tmp_ctx == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}
	err = ndr_push_struct_blob(&blob, tmp_ctx, object, (ndr_push_flags_fn_t)ndr_push_cab_file);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(tmp_ctx);
		PyErr_SetNdrError(err);
		return NULL;
	}

	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(tmp_ctx);
	return ret;
}

static PyObject *py_cab_file_ndr_unpack(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	struct cab_file *object = (struct cab_file *)pytalloc_get_ptr(py_obj);
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	enum ndr_err_code err;
	const char * const kwnames[] = { "data_blob", "allow_remaining", NULL };
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|O:__ndr_unpack__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	if (allow_remaining) {
		err = ndr_pull_struct_blob(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_cab_file);
	} else {
		err = ndr_pull_struct_blob_all(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_cab_file);
	}
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		PyErr_SetNdrError(err);
		return NULL;
	}

	Py_RETURN_NONE;
}

static PyObject *py_cab_file_ndr_print(PyObject *py_obj)
{
	struct cab_file *object = (struct cab_file *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	retstr = ndr_print_struct_string(pytalloc_get_mem_ctx(py_obj), (ndr_print_fn_t)ndr_print_cab_file, "cab_file", object);
	ret = PyStr_FromString(retstr);
	talloc_free(retstr);

	return ret;
}

static PyMethodDef py_cab_file_methods[] = {
	{ "__ndr_pack__", (PyCFunction)py_cab_file_ndr_pack, METH_NOARGS, "S.ndr_pack(object) -> blob\nNDR pack" },
	{ "__ndr_unpack__", (PyCFunction)py_cab_file_ndr_unpack, METH_VARARGS|METH_KEYWORDS, "S.ndr_unpack(class, blob, allow_remaining=False) -> None\nNDR unpack" },
	{ "__ndr_print__", (PyCFunction)py_cab_file_ndr_print, METH_NOARGS, "S.ndr_print(object) -> None\nNDR print" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject cab_file_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "cab.file",
	.tp_getset = py_cab_file_getsetters,
	.tp_methods = py_cab_file_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_cab_file_new,
};



static PyObject *py_decode_cab_file_in_get_file(PyObject *obj, void *closure)
{
	struct decode_cab_file *object = (struct decode_cab_file *)pytalloc_get_ptr(obj);
	PyObject *py_file;
	py_file = pytalloc_reference_ex(&cab_file_Type, pytalloc_get_mem_ctx(obj), &object->in.file);
	return py_file;
}

static int py_decode_cab_file_in_set_file(PyObject *py_obj, PyObject *value, void *closure)
{
	struct decode_cab_file *object = (struct decode_cab_file *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.file");
		return -1;
	}
	PY_CHECK_TYPE(&cab_file_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.file = *(struct cab_file *)pytalloc_get_ptr(value);
	return 0;
}

static PyGetSetDef py_decode_cab_file_getsetters[] = {
	{
		.name = discard_const_p(char, "in_file"),
		.get = py_decode_cab_file_in_get_file,
		.set = py_decode_cab_file_in_set_file,
		.doc = discard_const_p(char, "PIDL-generated element of base type cab_file")
	},
	{ .name = NULL }
};

static PyObject *py_decode_cab_file_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct decode_cab_file, type);
}

static PyObject *py_decode_cab_file_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(0);
}

static PyObject *py_decode_cab_file_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct decode_cab_file *object = (struct decode_cab_file *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_cab.num_calls < 1) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_decode_cab_file_ndr_pack");
		return NULL;
	}
	call = &ndr_table_cab.calls[0];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_decode_cab_file_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_decode_cab_file_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_decode_cab_file_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_decode_cab_file_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_decode_cab_file_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct decode_cab_file *object = (struct decode_cab_file *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_cab.num_calls < 1) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_decode_cab_file_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_cab.calls[0];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_decode_cab_file_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_decode_cab_file_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_decode_cab_file_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_decode_cab_file_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_decode_cab_file_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct decode_cab_file *object = (struct decode_cab_file *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_cab.num_calls < 1) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_decode_cab_file_ndr_print");
		return NULL;
	}
	call = &ndr_table_cab.calls[0];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_decode_cab_file_ndr_print_in(PyObject *py_obj)
{
	return py_decode_cab_file_ndr_print(py_obj, "decode_cab_file_in", NDR_IN);
}

static PyObject *py_decode_cab_file_ndr_print_out(PyObject *py_obj)
{
	return py_decode_cab_file_ndr_print(py_obj, "decode_cab_file_out", NDR_OUT);
}

static PyMethodDef py_decode_cab_file_methods[] = {
	{ "opnum", (PyCFunction)py_decode_cab_file_ndr_opnum, METH_NOARGS|METH_CLASS,
		"cab.decode_cab_file.opnum() -> 0 (0x00) " },
	{ "__ndr_pack_in__", (PyCFunction)py_decode_cab_file_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_decode_cab_file_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_decode_cab_file_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_decode_cab_file_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_decode_cab_file_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_decode_cab_file_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject decode_cab_file_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "cab.decode_cab_file",
	.tp_getset = py_decode_cab_file_getsetters,
	.tp_methods = py_decode_cab_file_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_decode_cab_file_new,
};

static bool pack_py_decode_cab_file_args_in(PyObject *args, PyObject *kwargs, struct decode_cab_file *r)
{
	PyObject *py_file;
	const char *kwnames[] = {
		"file", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:decode_cab_file", discard_const_p(char *, kwnames), &py_file)) {
		return false;
	}

	if (py_file == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.file");
		return false;
	}
	PY_CHECK_TYPE(&cab_file_Type, py_file, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_file)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.file = *(struct cab_file *)pytalloc_get_ptr(py_file);
	return true;
}

static PyObject *unpack_py_decode_cab_file_args_out(struct decode_cab_file *r)
{
	PyObject *result;
	result = Py_None;
	Py_INCREF(result);
	return result;
}

const struct PyNdrRpcMethodDef py_ndr_cab_methods[] = {
	{ "decode_cab_file", "S.decode_cab_file(file) -> None", (py_dcerpc_call_fn)dcerpc_decode_cab_file_r, (py_data_pack_fn)pack_py_decode_cab_file_args_in, (py_data_unpack_fn)unpack_py_decode_cab_file_args_out, 0, &ndr_table_cab },
	{ NULL }
};

static PyObject *interface_cab_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return py_dcerpc_interface_init_helper(type, args, kwargs, &ndr_table_cab);
}

#define PY_DOC_CAB "Cabinet structure"
static PyTypeObject cab_InterfaceType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "cab.cab",
	.tp_basicsize = sizeof(dcerpc_InterfaceObject),
	.tp_doc = "cab(binding, lp_ctx=None, credentials=None) -> connection\n"
"\n"
"binding should be a DCE/RPC binding string (for example: ncacn_ip_tcp:127.0.0.1)\n"
"lp_ctx should be a path to a smb.conf file or a param.LoadParm object\n"
"credentials should be a credentials.Credentials object.\n\n"PY_DOC_CAB,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = interface_cab_new,
};

static PyObject *syntax_cab_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return py_dcerpc_syntax_init_helper(type, args, kwargs, &ndr_table_cab.syntax_id);
}

#define PY_DOC_CAB_SYNTAX "Cabinet structure"
static PyTypeObject cab_SyntaxType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "cab.cab_abstract_syntax",
	.tp_doc = "cab_abstract_syntax()\n"PY_DOC_CAB_SYNTAX,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = syntax_cab_new,
};

static PyMethodDef cab_methods[] = {
	{ NULL, NULL, 0, NULL }
};

static struct PyModuleDef moduledef = {
	PyModuleDef_HEAD_INIT,
	.m_name = "cab",
	.m_doc = "cab DCE/RPC",
	.m_size = -1,
	.m_methods = cab_methods,
};
MODULE_INIT_FUNC(cab)
{
	PyObject *m;
	PyObject *dep_samba_dcerpc_misc;
	PyObject *dep_talloc;
	PyObject *dep_samba_dcerpc_base;

	dep_samba_dcerpc_misc = PyImport_ImportModule("samba.dcerpc.misc");
	if (dep_samba_dcerpc_misc == NULL)
		return NULL;

	dep_talloc = PyImport_ImportModule("talloc");
	if (dep_talloc == NULL)
		return NULL;

	dep_samba_dcerpc_base = PyImport_ImportModule("samba.dcerpc.base");
	if (dep_samba_dcerpc_base == NULL)
		return NULL;

	BaseObject_Type = (PyTypeObject *)PyObject_GetAttrString(dep_talloc, "BaseObject");
	if (BaseObject_Type == NULL)
		return NULL;

	ClientConnection_Type = (PyTypeObject *)PyObject_GetAttrString(dep_samba_dcerpc_base, "ClientConnection");
	if (ClientConnection_Type == NULL)
		return NULL;

	ndr_syntax_id_Type = (PyTypeObject *)PyObject_GetAttrString(dep_samba_dcerpc_misc, "ndr_syntax_id");
	if (ndr_syntax_id_Type == NULL)
		return NULL;

	CFHEADER_Type.tp_base = BaseObject_Type;
	CFHEADER_Type.tp_basicsize = pytalloc_BaseObject_size();

	CFFOLDER_Type.tp_base = BaseObject_Type;
	CFFOLDER_Type.tp_basicsize = pytalloc_BaseObject_size();

	cf_date_Type.tp_base = BaseObject_Type;
	cf_date_Type.tp_basicsize = pytalloc_BaseObject_size();

	cf_time_Type.tp_base = BaseObject_Type;
	cf_time_Type.tp_basicsize = pytalloc_BaseObject_size();

	CFFILE_Type.tp_base = BaseObject_Type;
	CFFILE_Type.tp_basicsize = pytalloc_BaseObject_size();

	CFDATA_Type.tp_base = BaseObject_Type;
	CFDATA_Type.tp_basicsize = pytalloc_BaseObject_size();

	cab_file_Type.tp_base = BaseObject_Type;
	cab_file_Type.tp_basicsize = pytalloc_BaseObject_size();

	decode_cab_file_Type.tp_base = BaseObject_Type;
	decode_cab_file_Type.tp_basicsize = pytalloc_BaseObject_size();

	cab_InterfaceType.tp_base = ClientConnection_Type;

	cab_SyntaxType.tp_base = ndr_syntax_id_Type;
	cab_SyntaxType.tp_basicsize = pytalloc_BaseObject_size();

	if (PyType_Ready(&CFHEADER_Type) < 0)
		return NULL;
	if (PyType_Ready(&CFFOLDER_Type) < 0)
		return NULL;
	if (PyType_Ready(&cf_date_Type) < 0)
		return NULL;
	if (PyType_Ready(&cf_time_Type) < 0)
		return NULL;
	if (PyType_Ready(&CFFILE_Type) < 0)
		return NULL;
	if (PyType_Ready(&CFDATA_Type) < 0)
		return NULL;
	if (PyType_Ready(&cab_file_Type) < 0)
		return NULL;
	if (PyType_Ready(&decode_cab_file_Type) < 0)
		return NULL;
	if (PyType_Ready(&cab_InterfaceType) < 0)
		return NULL;
	if (PyType_Ready(&cab_SyntaxType) < 0)
		return NULL;
	if (!PyInterface_AddNdrRpcMethods(&cab_InterfaceType, py_ndr_cab_methods))
		return NULL;

#ifdef PY_CFHEADER_PATCH
	PY_CFHEADER_PATCH(&CFHEADER_Type);
#endif
#ifdef PY_CFFOLDER_PATCH
	PY_CFFOLDER_PATCH(&CFFOLDER_Type);
#endif
#ifdef PY_CF_DATE_PATCH
	PY_CF_DATE_PATCH(&cf_date_Type);
#endif
#ifdef PY_CF_TIME_PATCH
	PY_CF_TIME_PATCH(&cf_time_Type);
#endif
#ifdef PY_CFFILE_PATCH
	PY_CFFILE_PATCH(&CFFILE_Type);
#endif
#ifdef PY_CFDATA_PATCH
	PY_CFDATA_PATCH(&CFDATA_Type);
#endif
#ifdef PY_FILE_PATCH
	PY_FILE_PATCH(&cab_file_Type);
#endif
#ifdef PY_DECODE_CAB_FILE_PATCH
	PY_DECODE_CAB_FILE_PATCH(&decode_cab_file_Type);
#endif
#ifdef PY_CAB_PATCH
	PY_CAB_PATCH(&cab_InterfaceType);
#endif
#ifdef PY_CAB_ABSTRACT_SYNTAX_PATCH
	PY_CAB_ABSTRACT_SYNTAX_PATCH(&cab_SyntaxType);
#endif
#ifdef PY_ABSTRACT_SYNTAX_PATCH
	PY_ABSTRACT_SYNTAX_PATCH(&cab_SyntaxType);
#endif

	m = PyModule_Create(&moduledef);
	if (m == NULL)
		return NULL;

	PyModule_AddObject(m, "ifoldCONTINUED_FROM_PREV", ndr_PyLong_FromUnsignedLongLong(0xFFFD));
	PyModule_AddObject(m, "ifoldCONTINUED_TO_NEXT", ndr_PyLong_FromUnsignedLongLong(0xFFFE));
	PyModule_AddObject(m, "ifoldCONTINUED_PREV_AND_NEXT", ndr_PyLong_FromUnsignedLongLong(0xFFFF));
	PyModule_AddObject(m, "cfhdrPREV_CABINET", PyInt_FromLong((uint16_t)cfhdrPREV_CABINET));
	PyModule_AddObject(m, "cfhdrNEXT_CABINET", PyInt_FromLong((uint16_t)cfhdrNEXT_CABINET));
	PyModule_AddObject(m, "cfhdrRESERVE_PRESENT", PyInt_FromLong((uint16_t)cfhdrRESERVE_PRESENT));
	PyModule_AddObject(m, "CF_COMPRESS_NONE", PyInt_FromLong((uint16_t)CF_COMPRESS_NONE));
	PyModule_AddObject(m, "CF_COMPRESS_MSZIP", PyInt_FromLong((uint16_t)CF_COMPRESS_MSZIP));
	PyModule_AddObject(m, "CF_COMPRESS_LZX", PyInt_FromLong((uint16_t)CF_COMPRESS_LZX));
	PyModule_AddObject(m, "_A_RDONLY", PyInt_FromLong((uint16_t)_A_RDONLY));
	PyModule_AddObject(m, "_A_HIDDEN", PyInt_FromLong((uint16_t)_A_HIDDEN));
	PyModule_AddObject(m, "_A_SYSTEM", PyInt_FromLong((uint16_t)_A_SYSTEM));
	PyModule_AddObject(m, "_A_ARCH", PyInt_FromLong((uint16_t)_A_ARCH));
	PyModule_AddObject(m, "_A_EXEC", PyInt_FromLong((uint16_t)_A_EXEC));
	PyModule_AddObject(m, "_A_NAME_IS_UTF", PyInt_FromLong((uint16_t)_A_NAME_IS_UTF));
	Py_INCREF((PyObject *)(void *)&CFHEADER_Type);
	PyModule_AddObject(m, "CFHEADER", (PyObject *)(void *)&CFHEADER_Type);
	Py_INCREF((PyObject *)(void *)&CFFOLDER_Type);
	PyModule_AddObject(m, "CFFOLDER", (PyObject *)(void *)&CFFOLDER_Type);
	Py_INCREF((PyObject *)(void *)&cf_date_Type);
	PyModule_AddObject(m, "cf_date", (PyObject *)(void *)&cf_date_Type);
	Py_INCREF((PyObject *)(void *)&cf_time_Type);
	PyModule_AddObject(m, "cf_time", (PyObject *)(void *)&cf_time_Type);
	Py_INCREF((PyObject *)(void *)&CFFILE_Type);
	PyModule_AddObject(m, "CFFILE", (PyObject *)(void *)&CFFILE_Type);
	Py_INCREF((PyObject *)(void *)&CFDATA_Type);
	PyModule_AddObject(m, "CFDATA", (PyObject *)(void *)&CFDATA_Type);
	Py_INCREF((PyObject *)(void *)&cab_file_Type);
	PyModule_AddObject(m, "file", (PyObject *)(void *)&cab_file_Type);
	Py_INCREF((PyObject *)(void *)&decode_cab_file_Type);
	PyModule_AddObject(m, "decode_cab_file", (PyObject *)(void *)&decode_cab_file_Type);
	Py_INCREF((PyObject *)(void *)&cab_InterfaceType);
	PyModule_AddObject(m, "cab", (PyObject *)(void *)&cab_InterfaceType);
	Py_INCREF((PyObject *)(void *)&cab_SyntaxType);
	PyModule_AddObject(m, "cab_abstract_syntax", (PyObject *)(void *)&cab_SyntaxType);
	Py_INCREF((PyObject *)(void *)&cab_SyntaxType);
	PyModule_AddObject(m, "abstract_syntax", (PyObject *)(void *)&cab_SyntaxType);
#ifdef PY_MOD_CAB_PATCH
	PY_MOD_CAB_PATCH(m);
#endif
	return m;

}
