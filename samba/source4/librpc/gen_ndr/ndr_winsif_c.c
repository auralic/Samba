/* client functions auto-generated by pidl */

#include "includes.h"
#include <tevent.h>
#include "lib/util/tevent_ntstatus.h"
#include "bin/default/source4/librpc/gen_ndr/ndr_winsif.h"
#include "bin/default/source4/librpc/gen_ndr/ndr_winsif_c.h"

/* winsif - client functions generated by pidl */

struct dcerpc_winsif_WinsRecordAction_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_winsif_WinsRecordAction_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_winsif_WinsRecordAction_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct winsif_WinsRecordAction *r)
{
	struct tevent_req *req;
	struct dcerpc_winsif_WinsRecordAction_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_winsif_WinsRecordAction_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = talloc_new(state);
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_winsif,
			NDR_WINSIF_WINSRECORDACTION, state->out_mem_ctx, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_winsif_WinsRecordAction_r_done, req);

	return req;
}

static void dcerpc_winsif_WinsRecordAction_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	TALLOC_FREE(subreq);
	if (tevent_req_nterror(req, status)) {
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_winsif_WinsRecordAction_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_winsif_WinsRecordAction_r_state *state =
		tevent_req_data(req,
		struct dcerpc_winsif_WinsRecordAction_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_winsif_WinsRecordAction_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct winsif_WinsRecordAction *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_winsif,
			NDR_WINSIF_WINSRECORDACTION, mem_ctx, r);

	return status;
}

struct dcerpc_winsif_WinsRecordAction_state {
	struct winsif_WinsRecordAction orig;
	struct winsif_WinsRecordAction tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_winsif_WinsRecordAction_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_winsif_WinsRecordAction_send(TALLOC_CTX *mem_ctx,
						       struct tevent_context *ev,
						       struct dcerpc_binding_handle *h,
						       struct winsif_RecordAction **_record_action /* [in,out] [ref] */)
{
	struct tevent_req *req;
	struct dcerpc_winsif_WinsRecordAction_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_winsif_WinsRecordAction_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.record_action = _record_action;

	/* Out parameters */
	state->orig.out.record_action = _record_action;

	/* Result */
	ZERO_STRUCT(state->orig.out.result);

	state->out_mem_ctx = talloc_named_const(state, 0,
			     "dcerpc_winsif_WinsRecordAction_out_memory");
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_winsif_WinsRecordAction_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_winsif_WinsRecordAction_done, req);
	return req;
}

static void dcerpc_winsif_WinsRecordAction_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_winsif_WinsRecordAction_state *state = tevent_req_data(
		req, struct dcerpc_winsif_WinsRecordAction_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_winsif_WinsRecordAction_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (tevent_req_nterror(req, status)) {
		return;
	}

	/* Copy out parameters */
	*state->orig.out.record_action = *state->tmp.out.record_action;

	/* Copy result */
	state->orig.out.result = state->tmp.out.result;

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_winsif_WinsRecordAction_recv(struct tevent_req *req,
					     TALLOC_CTX *mem_ctx,
					     WERROR *result)
{
	struct dcerpc_winsif_WinsRecordAction_state *state = tevent_req_data(
		req, struct dcerpc_winsif_WinsRecordAction_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	/* Return result */
	*result = state->orig.out.result;

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_winsif_WinsRecordAction(struct dcerpc_binding_handle *h,
					TALLOC_CTX *mem_ctx,
					struct winsif_RecordAction **_record_action /* [in,out] [ref] */,
					WERROR *result)
{
	struct winsif_WinsRecordAction r;
	NTSTATUS status;

	/* In parameters */
	r.in.record_action = _record_action;

	/* Out parameters */
	r.out.record_action = _record_action;

	/* Result */
	ZERO_STRUCT(r.out.result);

	status = dcerpc_winsif_WinsRecordAction_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */
	*_record_action = *r.out.record_action;

	/* Return result */
	*result = r.out.result;

	return NT_STATUS_OK;
}

struct dcerpc_winsif_WinsStatus_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_winsif_WinsStatus_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_winsif_WinsStatus_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct winsif_WinsStatus *r)
{
	struct tevent_req *req;
	struct dcerpc_winsif_WinsStatus_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_winsif_WinsStatus_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = talloc_new(state);
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_winsif,
			NDR_WINSIF_WINSSTATUS, state->out_mem_ctx, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_winsif_WinsStatus_r_done, req);

	return req;
}

static void dcerpc_winsif_WinsStatus_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	TALLOC_FREE(subreq);
	if (tevent_req_nterror(req, status)) {
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_winsif_WinsStatus_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_winsif_WinsStatus_r_state *state =
		tevent_req_data(req,
		struct dcerpc_winsif_WinsStatus_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_winsif_WinsStatus_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct winsif_WinsStatus *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_winsif,
			NDR_WINSIF_WINSSTATUS, mem_ctx, r);

	return status;
}

struct dcerpc_winsif_WinsStatus_state {
	struct winsif_WinsStatus orig;
	struct winsif_WinsStatus tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_winsif_WinsStatus_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_winsif_WinsStatus_send(TALLOC_CTX *mem_ctx,
						 struct tevent_context *ev,
						 struct dcerpc_binding_handle *h,
						 enum winsif_StatusCmd _cmd /* [in]  */,
						 struct winsif_Results *_results /* [in,out] [ref] */)
{
	struct tevent_req *req;
	struct dcerpc_winsif_WinsStatus_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_winsif_WinsStatus_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.cmd = _cmd;
	state->orig.in.results = _results;

	/* Out parameters */
	state->orig.out.results = _results;

	/* Result */
	ZERO_STRUCT(state->orig.out.result);

	state->out_mem_ctx = talloc_named_const(state, 0,
			     "dcerpc_winsif_WinsStatus_out_memory");
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_winsif_WinsStatus_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_winsif_WinsStatus_done, req);
	return req;
}

static void dcerpc_winsif_WinsStatus_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_winsif_WinsStatus_state *state = tevent_req_data(
		req, struct dcerpc_winsif_WinsStatus_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_winsif_WinsStatus_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (tevent_req_nterror(req, status)) {
		return;
	}

	/* Copy out parameters */
	*state->orig.out.results = *state->tmp.out.results;

	/* Copy result */
	state->orig.out.result = state->tmp.out.result;

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_winsif_WinsStatus_recv(struct tevent_req *req,
				       TALLOC_CTX *mem_ctx,
				       WERROR *result)
{
	struct dcerpc_winsif_WinsStatus_state *state = tevent_req_data(
		req, struct dcerpc_winsif_WinsStatus_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	/* Return result */
	*result = state->orig.out.result;

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_winsif_WinsStatus(struct dcerpc_binding_handle *h,
				  TALLOC_CTX *mem_ctx,
				  enum winsif_StatusCmd _cmd /* [in]  */,
				  struct winsif_Results *_results /* [in,out] [ref] */,
				  WERROR *result)
{
	struct winsif_WinsStatus r;
	NTSTATUS status;

	/* In parameters */
	r.in.cmd = _cmd;
	r.in.results = _results;

	/* Out parameters */
	r.out.results = _results;

	/* Result */
	ZERO_STRUCT(r.out.result);

	status = dcerpc_winsif_WinsStatus_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */
	*_results = *r.out.results;

	/* Return result */
	*result = r.out.result;

	return NT_STATUS_OK;
}

struct dcerpc_winsif_WinsTrigger_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_winsif_WinsTrigger_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_winsif_WinsTrigger_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct winsif_WinsTrigger *r)
{
	struct tevent_req *req;
	struct dcerpc_winsif_WinsTrigger_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_winsif_WinsTrigger_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = NULL;

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_winsif,
			NDR_WINSIF_WINSTRIGGER, state, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_winsif_WinsTrigger_r_done, req);

	return req;
}

static void dcerpc_winsif_WinsTrigger_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	TALLOC_FREE(subreq);
	if (tevent_req_nterror(req, status)) {
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_winsif_WinsTrigger_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_winsif_WinsTrigger_r_state *state =
		tevent_req_data(req,
		struct dcerpc_winsif_WinsTrigger_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_winsif_WinsTrigger_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct winsif_WinsTrigger *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_winsif,
			NDR_WINSIF_WINSTRIGGER, mem_ctx, r);

	return status;
}

struct dcerpc_winsif_WinsTrigger_state {
	struct winsif_WinsTrigger orig;
	struct winsif_WinsTrigger tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_winsif_WinsTrigger_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_winsif_WinsTrigger_send(TALLOC_CTX *mem_ctx,
						  struct tevent_context *ev,
						  struct dcerpc_binding_handle *h,
						  struct winsif_Address *_owner_address /* [in] [ref] */,
						  enum winsif_TriggerType _trigger_type /* [in]  */)
{
	struct tevent_req *req;
	struct dcerpc_winsif_WinsTrigger_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_winsif_WinsTrigger_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.owner_address = _owner_address;
	state->orig.in.trigger_type = _trigger_type;

	/* Out parameters */

	/* Result */
	ZERO_STRUCT(state->orig.out.result);

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_winsif_WinsTrigger_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_winsif_WinsTrigger_done, req);
	return req;
}

static void dcerpc_winsif_WinsTrigger_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_winsif_WinsTrigger_state *state = tevent_req_data(
		req, struct dcerpc_winsif_WinsTrigger_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_winsif_WinsTrigger_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (tevent_req_nterror(req, status)) {
		return;
	}

	/* Copy out parameters */

	/* Copy result */
	state->orig.out.result = state->tmp.out.result;

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_winsif_WinsTrigger_recv(struct tevent_req *req,
					TALLOC_CTX *mem_ctx,
					WERROR *result)
{
	struct dcerpc_winsif_WinsTrigger_state *state = tevent_req_data(
		req, struct dcerpc_winsif_WinsTrigger_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	/* Return result */
	*result = state->orig.out.result;

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_winsif_WinsTrigger(struct dcerpc_binding_handle *h,
				   TALLOC_CTX *mem_ctx,
				   struct winsif_Address *_owner_address /* [in] [ref] */,
				   enum winsif_TriggerType _trigger_type /* [in]  */,
				   WERROR *result)
{
	struct winsif_WinsTrigger r;
	NTSTATUS status;

	/* In parameters */
	r.in.owner_address = _owner_address;
	r.in.trigger_type = _trigger_type;

	/* Out parameters */

	/* Result */
	ZERO_STRUCT(r.out.result);

	status = dcerpc_winsif_WinsTrigger_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */

	/* Return result */
	*result = r.out.result;

	return NT_STATUS_OK;
}

struct dcerpc_winsif_WinsDoStaticInit_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_winsif_WinsDoStaticInit_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_winsif_WinsDoStaticInit_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct winsif_WinsDoStaticInit *r)
{
	struct tevent_req *req;
	struct dcerpc_winsif_WinsDoStaticInit_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_winsif_WinsDoStaticInit_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = NULL;

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_winsif,
			NDR_WINSIF_WINSDOSTATICINIT, state, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_winsif_WinsDoStaticInit_r_done, req);

	return req;
}

static void dcerpc_winsif_WinsDoStaticInit_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	TALLOC_FREE(subreq);
	if (tevent_req_nterror(req, status)) {
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_winsif_WinsDoStaticInit_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_winsif_WinsDoStaticInit_r_state *state =
		tevent_req_data(req,
		struct dcerpc_winsif_WinsDoStaticInit_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_winsif_WinsDoStaticInit_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct winsif_WinsDoStaticInit *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_winsif,
			NDR_WINSIF_WINSDOSTATICINIT, mem_ctx, r);

	return status;
}

struct dcerpc_winsif_WinsDoStaticInit_state {
	struct winsif_WinsDoStaticInit orig;
	struct winsif_WinsDoStaticInit tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_winsif_WinsDoStaticInit_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_winsif_WinsDoStaticInit_send(TALLOC_CTX *mem_ctx,
						       struct tevent_context *ev,
						       struct dcerpc_binding_handle *h,
						       const char *_data_file_path /* [in] [charset(UTF16),unique] */,
						       uint32_t _delete_file /* [in]  */)
{
	struct tevent_req *req;
	struct dcerpc_winsif_WinsDoStaticInit_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_winsif_WinsDoStaticInit_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.data_file_path = _data_file_path;
	state->orig.in.delete_file = _delete_file;

	/* Out parameters */

	/* Result */
	ZERO_STRUCT(state->orig.out.result);

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_winsif_WinsDoStaticInit_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_winsif_WinsDoStaticInit_done, req);
	return req;
}

static void dcerpc_winsif_WinsDoStaticInit_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_winsif_WinsDoStaticInit_state *state = tevent_req_data(
		req, struct dcerpc_winsif_WinsDoStaticInit_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_winsif_WinsDoStaticInit_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (tevent_req_nterror(req, status)) {
		return;
	}

	/* Copy out parameters */

	/* Copy result */
	state->orig.out.result = state->tmp.out.result;

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_winsif_WinsDoStaticInit_recv(struct tevent_req *req,
					     TALLOC_CTX *mem_ctx,
					     WERROR *result)
{
	struct dcerpc_winsif_WinsDoStaticInit_state *state = tevent_req_data(
		req, struct dcerpc_winsif_WinsDoStaticInit_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	/* Return result */
	*result = state->orig.out.result;

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_winsif_WinsDoStaticInit(struct dcerpc_binding_handle *h,
					TALLOC_CTX *mem_ctx,
					const char *_data_file_path /* [in] [charset(UTF16),unique] */,
					uint32_t _delete_file /* [in]  */,
					WERROR *result)
{
	struct winsif_WinsDoStaticInit r;
	NTSTATUS status;

	/* In parameters */
	r.in.data_file_path = _data_file_path;
	r.in.delete_file = _delete_file;

	/* Out parameters */

	/* Result */
	ZERO_STRUCT(r.out.result);

	status = dcerpc_winsif_WinsDoStaticInit_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */

	/* Return result */
	*result = r.out.result;

	return NT_STATUS_OK;
}

struct dcerpc_winsif_WinsDoScavenging_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_winsif_WinsDoScavenging_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_winsif_WinsDoScavenging_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct winsif_WinsDoScavenging *r)
{
	struct tevent_req *req;
	struct dcerpc_winsif_WinsDoScavenging_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_winsif_WinsDoScavenging_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = NULL;

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_winsif,
			NDR_WINSIF_WINSDOSCAVENGING, state, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_winsif_WinsDoScavenging_r_done, req);

	return req;
}

static void dcerpc_winsif_WinsDoScavenging_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	TALLOC_FREE(subreq);
	if (tevent_req_nterror(req, status)) {
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_winsif_WinsDoScavenging_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_winsif_WinsDoScavenging_r_state *state =
		tevent_req_data(req,
		struct dcerpc_winsif_WinsDoScavenging_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_winsif_WinsDoScavenging_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct winsif_WinsDoScavenging *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_winsif,
			NDR_WINSIF_WINSDOSCAVENGING, mem_ctx, r);

	return status;
}

struct dcerpc_winsif_WinsDoScavenging_state {
	struct winsif_WinsDoScavenging orig;
	struct winsif_WinsDoScavenging tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_winsif_WinsDoScavenging_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_winsif_WinsDoScavenging_send(TALLOC_CTX *mem_ctx,
						       struct tevent_context *ev,
						       struct dcerpc_binding_handle *h)
{
	struct tevent_req *req;
	struct dcerpc_winsif_WinsDoScavenging_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_winsif_WinsDoScavenging_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */

	/* Out parameters */

	/* Result */
	ZERO_STRUCT(state->orig.out.result);

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_winsif_WinsDoScavenging_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_winsif_WinsDoScavenging_done, req);
	return req;
}

static void dcerpc_winsif_WinsDoScavenging_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_winsif_WinsDoScavenging_state *state = tevent_req_data(
		req, struct dcerpc_winsif_WinsDoScavenging_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_winsif_WinsDoScavenging_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (tevent_req_nterror(req, status)) {
		return;
	}

	/* Copy out parameters */

	/* Copy result */
	state->orig.out.result = state->tmp.out.result;

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_winsif_WinsDoScavenging_recv(struct tevent_req *req,
					     TALLOC_CTX *mem_ctx,
					     WERROR *result)
{
	struct dcerpc_winsif_WinsDoScavenging_state *state = tevent_req_data(
		req, struct dcerpc_winsif_WinsDoScavenging_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	/* Return result */
	*result = state->orig.out.result;

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_winsif_WinsDoScavenging(struct dcerpc_binding_handle *h,
					TALLOC_CTX *mem_ctx,
					WERROR *result)
{
	struct winsif_WinsDoScavenging r;
	NTSTATUS status;

	/* In parameters */

	/* Out parameters */

	/* Result */
	ZERO_STRUCT(r.out.result);

	status = dcerpc_winsif_WinsDoScavenging_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */

	/* Return result */
	*result = r.out.result;

	return NT_STATUS_OK;
}

struct dcerpc_winsif_WinsGetDbRecs_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_winsif_WinsGetDbRecs_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_winsif_WinsGetDbRecs_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct winsif_WinsGetDbRecs *r)
{
	struct tevent_req *req;
	struct dcerpc_winsif_WinsGetDbRecs_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_winsif_WinsGetDbRecs_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = talloc_new(state);
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_winsif,
			NDR_WINSIF_WINSGETDBRECS, state->out_mem_ctx, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_winsif_WinsGetDbRecs_r_done, req);

	return req;
}

static void dcerpc_winsif_WinsGetDbRecs_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	TALLOC_FREE(subreq);
	if (tevent_req_nterror(req, status)) {
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_winsif_WinsGetDbRecs_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_winsif_WinsGetDbRecs_r_state *state =
		tevent_req_data(req,
		struct dcerpc_winsif_WinsGetDbRecs_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_winsif_WinsGetDbRecs_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct winsif_WinsGetDbRecs *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_winsif,
			NDR_WINSIF_WINSGETDBRECS, mem_ctx, r);

	return status;
}

struct dcerpc_winsif_WinsGetDbRecs_state {
	struct winsif_WinsGetDbRecs orig;
	struct winsif_WinsGetDbRecs tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_winsif_WinsGetDbRecs_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_winsif_WinsGetDbRecs_send(TALLOC_CTX *mem_ctx,
						    struct tevent_context *ev,
						    struct dcerpc_binding_handle *h,
						    struct winsif_Address *_owner_address /* [in] [unique] */,
						    uint64_t _min_version_number /* [in]  */,
						    uint64_t _max_version_number /* [in]  */,
						    struct winsif_Records *_records /* [out] [ref] */)
{
	struct tevent_req *req;
	struct dcerpc_winsif_WinsGetDbRecs_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_winsif_WinsGetDbRecs_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.owner_address = _owner_address;
	state->orig.in.min_version_number = _min_version_number;
	state->orig.in.max_version_number = _max_version_number;

	/* Out parameters */
	state->orig.out.records = _records;

	/* Result */
	ZERO_STRUCT(state->orig.out.result);

	state->out_mem_ctx = talloc_named_const(state, 0,
			     "dcerpc_winsif_WinsGetDbRecs_out_memory");
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_winsif_WinsGetDbRecs_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_winsif_WinsGetDbRecs_done, req);
	return req;
}

static void dcerpc_winsif_WinsGetDbRecs_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_winsif_WinsGetDbRecs_state *state = tevent_req_data(
		req, struct dcerpc_winsif_WinsGetDbRecs_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_winsif_WinsGetDbRecs_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (tevent_req_nterror(req, status)) {
		return;
	}

	/* Copy out parameters */
	*state->orig.out.records = *state->tmp.out.records;

	/* Copy result */
	state->orig.out.result = state->tmp.out.result;

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_winsif_WinsGetDbRecs_recv(struct tevent_req *req,
					  TALLOC_CTX *mem_ctx,
					  WERROR *result)
{
	struct dcerpc_winsif_WinsGetDbRecs_state *state = tevent_req_data(
		req, struct dcerpc_winsif_WinsGetDbRecs_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	/* Return result */
	*result = state->orig.out.result;

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_winsif_WinsGetDbRecs(struct dcerpc_binding_handle *h,
				     TALLOC_CTX *mem_ctx,
				     struct winsif_Address *_owner_address /* [in] [unique] */,
				     uint64_t _min_version_number /* [in]  */,
				     uint64_t _max_version_number /* [in]  */,
				     struct winsif_Records *_records /* [out] [ref] */,
				     WERROR *result)
{
	struct winsif_WinsGetDbRecs r;
	NTSTATUS status;

	/* In parameters */
	r.in.owner_address = _owner_address;
	r.in.min_version_number = _min_version_number;
	r.in.max_version_number = _max_version_number;

	/* Out parameters */
	r.out.records = _records;

	/* Result */
	ZERO_STRUCT(r.out.result);

	status = dcerpc_winsif_WinsGetDbRecs_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */
	*_records = *r.out.records;

	/* Return result */
	*result = r.out.result;

	return NT_STATUS_OK;
}

struct dcerpc_winsif_WinsTerm_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_winsif_WinsTerm_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_winsif_WinsTerm_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct winsif_WinsTerm *r)
{
	struct tevent_req *req;
	struct dcerpc_winsif_WinsTerm_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_winsif_WinsTerm_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = NULL;

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_winsif,
			NDR_WINSIF_WINSTERM, state, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_winsif_WinsTerm_r_done, req);

	return req;
}

static void dcerpc_winsif_WinsTerm_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	TALLOC_FREE(subreq);
	if (tevent_req_nterror(req, status)) {
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_winsif_WinsTerm_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_winsif_WinsTerm_r_state *state =
		tevent_req_data(req,
		struct dcerpc_winsif_WinsTerm_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_winsif_WinsTerm_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct winsif_WinsTerm *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_winsif,
			NDR_WINSIF_WINSTERM, mem_ctx, r);

	return status;
}

struct dcerpc_winsif_WinsTerm_state {
	struct winsif_WinsTerm orig;
	struct winsif_WinsTerm tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_winsif_WinsTerm_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_winsif_WinsTerm_send(TALLOC_CTX *mem_ctx,
					       struct tevent_context *ev,
					       struct dcerpc_binding_handle *h,
					       uint16_t _abrupt_termination /* [in]  */)
{
	struct tevent_req *req;
	struct dcerpc_winsif_WinsTerm_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_winsif_WinsTerm_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.abrupt_termination = _abrupt_termination;

	/* Out parameters */

	/* Result */
	ZERO_STRUCT(state->orig.out.result);

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_winsif_WinsTerm_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_winsif_WinsTerm_done, req);
	return req;
}

static void dcerpc_winsif_WinsTerm_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_winsif_WinsTerm_state *state = tevent_req_data(
		req, struct dcerpc_winsif_WinsTerm_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_winsif_WinsTerm_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (tevent_req_nterror(req, status)) {
		return;
	}

	/* Copy out parameters */

	/* Copy result */
	state->orig.out.result = state->tmp.out.result;

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_winsif_WinsTerm_recv(struct tevent_req *req,
				     TALLOC_CTX *mem_ctx,
				     WERROR *result)
{
	struct dcerpc_winsif_WinsTerm_state *state = tevent_req_data(
		req, struct dcerpc_winsif_WinsTerm_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	/* Return result */
	*result = state->orig.out.result;

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_winsif_WinsTerm(struct dcerpc_binding_handle *h,
				TALLOC_CTX *mem_ctx,
				uint16_t _abrupt_termination /* [in]  */,
				WERROR *result)
{
	struct winsif_WinsTerm r;
	NTSTATUS status;

	/* In parameters */
	r.in.abrupt_termination = _abrupt_termination;

	/* Out parameters */

	/* Result */
	ZERO_STRUCT(r.out.result);

	status = dcerpc_winsif_WinsTerm_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */

	/* Return result */
	*result = r.out.result;

	return NT_STATUS_OK;
}

struct dcerpc_winsif_WinsBackup_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_winsif_WinsBackup_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_winsif_WinsBackup_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct winsif_WinsBackup *r)
{
	struct tevent_req *req;
	struct dcerpc_winsif_WinsBackup_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_winsif_WinsBackup_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = NULL;

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_winsif,
			NDR_WINSIF_WINSBACKUP, state, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_winsif_WinsBackup_r_done, req);

	return req;
}

static void dcerpc_winsif_WinsBackup_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	TALLOC_FREE(subreq);
	if (tevent_req_nterror(req, status)) {
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_winsif_WinsBackup_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_winsif_WinsBackup_r_state *state =
		tevent_req_data(req,
		struct dcerpc_winsif_WinsBackup_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_winsif_WinsBackup_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct winsif_WinsBackup *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_winsif,
			NDR_WINSIF_WINSBACKUP, mem_ctx, r);

	return status;
}

struct dcerpc_winsif_WinsBackup_state {
	struct winsif_WinsBackup orig;
	struct winsif_WinsBackup tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_winsif_WinsBackup_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_winsif_WinsBackup_send(TALLOC_CTX *mem_ctx,
						 struct tevent_context *ev,
						 struct dcerpc_binding_handle *h,
						 const char *_backup_path /* [in] [charset(DOS),ref] */,
						 uint16_t _incremental /* [in]  */)
{
	struct tevent_req *req;
	struct dcerpc_winsif_WinsBackup_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_winsif_WinsBackup_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.backup_path = _backup_path;
	state->orig.in.incremental = _incremental;

	/* Out parameters */

	/* Result */
	ZERO_STRUCT(state->orig.out.result);

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_winsif_WinsBackup_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_winsif_WinsBackup_done, req);
	return req;
}

static void dcerpc_winsif_WinsBackup_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_winsif_WinsBackup_state *state = tevent_req_data(
		req, struct dcerpc_winsif_WinsBackup_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_winsif_WinsBackup_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (tevent_req_nterror(req, status)) {
		return;
	}

	/* Copy out parameters */

	/* Copy result */
	state->orig.out.result = state->tmp.out.result;

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_winsif_WinsBackup_recv(struct tevent_req *req,
				       TALLOC_CTX *mem_ctx,
				       WERROR *result)
{
	struct dcerpc_winsif_WinsBackup_state *state = tevent_req_data(
		req, struct dcerpc_winsif_WinsBackup_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	/* Return result */
	*result = state->orig.out.result;

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_winsif_WinsBackup(struct dcerpc_binding_handle *h,
				  TALLOC_CTX *mem_ctx,
				  const char *_backup_path /* [in] [charset(DOS),ref] */,
				  uint16_t _incremental /* [in]  */,
				  WERROR *result)
{
	struct winsif_WinsBackup r;
	NTSTATUS status;

	/* In parameters */
	r.in.backup_path = _backup_path;
	r.in.incremental = _incremental;

	/* Out parameters */

	/* Result */
	ZERO_STRUCT(r.out.result);

	status = dcerpc_winsif_WinsBackup_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */

	/* Return result */
	*result = r.out.result;

	return NT_STATUS_OK;
}

struct dcerpc_winsif_WinsDelDbRecs_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_winsif_WinsDelDbRecs_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_winsif_WinsDelDbRecs_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct winsif_WinsDelDbRecs *r)
{
	struct tevent_req *req;
	struct dcerpc_winsif_WinsDelDbRecs_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_winsif_WinsDelDbRecs_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = NULL;

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_winsif,
			NDR_WINSIF_WINSDELDBRECS, state, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_winsif_WinsDelDbRecs_r_done, req);

	return req;
}

static void dcerpc_winsif_WinsDelDbRecs_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	TALLOC_FREE(subreq);
	if (tevent_req_nterror(req, status)) {
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_winsif_WinsDelDbRecs_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_winsif_WinsDelDbRecs_r_state *state =
		tevent_req_data(req,
		struct dcerpc_winsif_WinsDelDbRecs_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_winsif_WinsDelDbRecs_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct winsif_WinsDelDbRecs *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_winsif,
			NDR_WINSIF_WINSDELDBRECS, mem_ctx, r);

	return status;
}

struct dcerpc_winsif_WinsDelDbRecs_state {
	struct winsif_WinsDelDbRecs orig;
	struct winsif_WinsDelDbRecs tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_winsif_WinsDelDbRecs_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_winsif_WinsDelDbRecs_send(TALLOC_CTX *mem_ctx,
						    struct tevent_context *ev,
						    struct dcerpc_binding_handle *h,
						    struct winsif_Address *_owner_address /* [in] [ref] */,
						    uint64_t _min_version_number /* [in]  */,
						    uint64_t _max_version_number /* [in]  */)
{
	struct tevent_req *req;
	struct dcerpc_winsif_WinsDelDbRecs_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_winsif_WinsDelDbRecs_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.owner_address = _owner_address;
	state->orig.in.min_version_number = _min_version_number;
	state->orig.in.max_version_number = _max_version_number;

	/* Out parameters */

	/* Result */
	ZERO_STRUCT(state->orig.out.result);

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_winsif_WinsDelDbRecs_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_winsif_WinsDelDbRecs_done, req);
	return req;
}

static void dcerpc_winsif_WinsDelDbRecs_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_winsif_WinsDelDbRecs_state *state = tevent_req_data(
		req, struct dcerpc_winsif_WinsDelDbRecs_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_winsif_WinsDelDbRecs_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (tevent_req_nterror(req, status)) {
		return;
	}

	/* Copy out parameters */

	/* Copy result */
	state->orig.out.result = state->tmp.out.result;

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_winsif_WinsDelDbRecs_recv(struct tevent_req *req,
					  TALLOC_CTX *mem_ctx,
					  WERROR *result)
{
	struct dcerpc_winsif_WinsDelDbRecs_state *state = tevent_req_data(
		req, struct dcerpc_winsif_WinsDelDbRecs_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	/* Return result */
	*result = state->orig.out.result;

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_winsif_WinsDelDbRecs(struct dcerpc_binding_handle *h,
				     TALLOC_CTX *mem_ctx,
				     struct winsif_Address *_owner_address /* [in] [ref] */,
				     uint64_t _min_version_number /* [in]  */,
				     uint64_t _max_version_number /* [in]  */,
				     WERROR *result)
{
	struct winsif_WinsDelDbRecs r;
	NTSTATUS status;

	/* In parameters */
	r.in.owner_address = _owner_address;
	r.in.min_version_number = _min_version_number;
	r.in.max_version_number = _max_version_number;

	/* Out parameters */

	/* Result */
	ZERO_STRUCT(r.out.result);

	status = dcerpc_winsif_WinsDelDbRecs_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */

	/* Return result */
	*result = r.out.result;

	return NT_STATUS_OK;
}

struct dcerpc_winsif_WinsPullRange_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_winsif_WinsPullRange_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_winsif_WinsPullRange_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct winsif_WinsPullRange *r)
{
	struct tevent_req *req;
	struct dcerpc_winsif_WinsPullRange_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_winsif_WinsPullRange_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = NULL;

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_winsif,
			NDR_WINSIF_WINSPULLRANGE, state, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_winsif_WinsPullRange_r_done, req);

	return req;
}

static void dcerpc_winsif_WinsPullRange_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	TALLOC_FREE(subreq);
	if (tevent_req_nterror(req, status)) {
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_winsif_WinsPullRange_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_winsif_WinsPullRange_r_state *state =
		tevent_req_data(req,
		struct dcerpc_winsif_WinsPullRange_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_winsif_WinsPullRange_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct winsif_WinsPullRange *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_winsif,
			NDR_WINSIF_WINSPULLRANGE, mem_ctx, r);

	return status;
}

struct dcerpc_winsif_WinsPullRange_state {
	struct winsif_WinsPullRange orig;
	struct winsif_WinsPullRange tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_winsif_WinsPullRange_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_winsif_WinsPullRange_send(TALLOC_CTX *mem_ctx,
						    struct tevent_context *ev,
						    struct dcerpc_binding_handle *h,
						    struct winsif_Address *_server_address /* [in] [ref] */,
						    struct winsif_Address *_owner_address /* [in] [ref] */,
						    uint64_t _min_version_number /* [in]  */,
						    uint64_t _max_version_number /* [in]  */)
{
	struct tevent_req *req;
	struct dcerpc_winsif_WinsPullRange_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_winsif_WinsPullRange_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.server_address = _server_address;
	state->orig.in.owner_address = _owner_address;
	state->orig.in.min_version_number = _min_version_number;
	state->orig.in.max_version_number = _max_version_number;

	/* Out parameters */

	/* Result */
	ZERO_STRUCT(state->orig.out.result);

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_winsif_WinsPullRange_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_winsif_WinsPullRange_done, req);
	return req;
}

static void dcerpc_winsif_WinsPullRange_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_winsif_WinsPullRange_state *state = tevent_req_data(
		req, struct dcerpc_winsif_WinsPullRange_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_winsif_WinsPullRange_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (tevent_req_nterror(req, status)) {
		return;
	}

	/* Copy out parameters */

	/* Copy result */
	state->orig.out.result = state->tmp.out.result;

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_winsif_WinsPullRange_recv(struct tevent_req *req,
					  TALLOC_CTX *mem_ctx,
					  WERROR *result)
{
	struct dcerpc_winsif_WinsPullRange_state *state = tevent_req_data(
		req, struct dcerpc_winsif_WinsPullRange_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	/* Return result */
	*result = state->orig.out.result;

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_winsif_WinsPullRange(struct dcerpc_binding_handle *h,
				     TALLOC_CTX *mem_ctx,
				     struct winsif_Address *_server_address /* [in] [ref] */,
				     struct winsif_Address *_owner_address /* [in] [ref] */,
				     uint64_t _min_version_number /* [in]  */,
				     uint64_t _max_version_number /* [in]  */,
				     WERROR *result)
{
	struct winsif_WinsPullRange r;
	NTSTATUS status;

	/* In parameters */
	r.in.server_address = _server_address;
	r.in.owner_address = _owner_address;
	r.in.min_version_number = _min_version_number;
	r.in.max_version_number = _max_version_number;

	/* Out parameters */

	/* Result */
	ZERO_STRUCT(r.out.result);

	status = dcerpc_winsif_WinsPullRange_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */

	/* Return result */
	*result = r.out.result;

	return NT_STATUS_OK;
}

struct dcerpc_winsif_WinsSetPriorityClass_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_winsif_WinsSetPriorityClass_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_winsif_WinsSetPriorityClass_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct winsif_WinsSetPriorityClass *r)
{
	struct tevent_req *req;
	struct dcerpc_winsif_WinsSetPriorityClass_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_winsif_WinsSetPriorityClass_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = NULL;

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_winsif,
			NDR_WINSIF_WINSSETPRIORITYCLASS, state, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_winsif_WinsSetPriorityClass_r_done, req);

	return req;
}

static void dcerpc_winsif_WinsSetPriorityClass_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	TALLOC_FREE(subreq);
	if (tevent_req_nterror(req, status)) {
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_winsif_WinsSetPriorityClass_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_winsif_WinsSetPriorityClass_r_state *state =
		tevent_req_data(req,
		struct dcerpc_winsif_WinsSetPriorityClass_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_winsif_WinsSetPriorityClass_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct winsif_WinsSetPriorityClass *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_winsif,
			NDR_WINSIF_WINSSETPRIORITYCLASS, mem_ctx, r);

	return status;
}

struct dcerpc_winsif_WinsSetPriorityClass_state {
	struct winsif_WinsSetPriorityClass orig;
	struct winsif_WinsSetPriorityClass tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_winsif_WinsSetPriorityClass_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_winsif_WinsSetPriorityClass_send(TALLOC_CTX *mem_ctx,
							   struct tevent_context *ev,
							   struct dcerpc_binding_handle *h,
							   enum winsif_PriorityClass _prioritiy_class /* [in]  */)
{
	struct tevent_req *req;
	struct dcerpc_winsif_WinsSetPriorityClass_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_winsif_WinsSetPriorityClass_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.prioritiy_class = _prioritiy_class;

	/* Out parameters */

	/* Result */
	ZERO_STRUCT(state->orig.out.result);

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_winsif_WinsSetPriorityClass_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_winsif_WinsSetPriorityClass_done, req);
	return req;
}

static void dcerpc_winsif_WinsSetPriorityClass_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_winsif_WinsSetPriorityClass_state *state = tevent_req_data(
		req, struct dcerpc_winsif_WinsSetPriorityClass_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_winsif_WinsSetPriorityClass_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (tevent_req_nterror(req, status)) {
		return;
	}

	/* Copy out parameters */

	/* Copy result */
	state->orig.out.result = state->tmp.out.result;

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_winsif_WinsSetPriorityClass_recv(struct tevent_req *req,
						 TALLOC_CTX *mem_ctx,
						 WERROR *result)
{
	struct dcerpc_winsif_WinsSetPriorityClass_state *state = tevent_req_data(
		req, struct dcerpc_winsif_WinsSetPriorityClass_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	/* Return result */
	*result = state->orig.out.result;

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_winsif_WinsSetPriorityClass(struct dcerpc_binding_handle *h,
					    TALLOC_CTX *mem_ctx,
					    enum winsif_PriorityClass _prioritiy_class /* [in]  */,
					    WERROR *result)
{
	struct winsif_WinsSetPriorityClass r;
	NTSTATUS status;

	/* In parameters */
	r.in.prioritiy_class = _prioritiy_class;

	/* Out parameters */

	/* Result */
	ZERO_STRUCT(r.out.result);

	status = dcerpc_winsif_WinsSetPriorityClass_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */

	/* Return result */
	*result = r.out.result;

	return NT_STATUS_OK;
}

struct dcerpc_winsif_WinsResetCounters_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_winsif_WinsResetCounters_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_winsif_WinsResetCounters_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct winsif_WinsResetCounters *r)
{
	struct tevent_req *req;
	struct dcerpc_winsif_WinsResetCounters_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_winsif_WinsResetCounters_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = NULL;

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_winsif,
			NDR_WINSIF_WINSRESETCOUNTERS, state, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_winsif_WinsResetCounters_r_done, req);

	return req;
}

static void dcerpc_winsif_WinsResetCounters_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	TALLOC_FREE(subreq);
	if (tevent_req_nterror(req, status)) {
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_winsif_WinsResetCounters_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_winsif_WinsResetCounters_r_state *state =
		tevent_req_data(req,
		struct dcerpc_winsif_WinsResetCounters_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_winsif_WinsResetCounters_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct winsif_WinsResetCounters *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_winsif,
			NDR_WINSIF_WINSRESETCOUNTERS, mem_ctx, r);

	return status;
}

struct dcerpc_winsif_WinsResetCounters_state {
	struct winsif_WinsResetCounters orig;
	struct winsif_WinsResetCounters tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_winsif_WinsResetCounters_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_winsif_WinsResetCounters_send(TALLOC_CTX *mem_ctx,
							struct tevent_context *ev,
							struct dcerpc_binding_handle *h)
{
	struct tevent_req *req;
	struct dcerpc_winsif_WinsResetCounters_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_winsif_WinsResetCounters_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */

	/* Out parameters */

	/* Result */
	ZERO_STRUCT(state->orig.out.result);

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_winsif_WinsResetCounters_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_winsif_WinsResetCounters_done, req);
	return req;
}

static void dcerpc_winsif_WinsResetCounters_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_winsif_WinsResetCounters_state *state = tevent_req_data(
		req, struct dcerpc_winsif_WinsResetCounters_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_winsif_WinsResetCounters_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (tevent_req_nterror(req, status)) {
		return;
	}

	/* Copy out parameters */

	/* Copy result */
	state->orig.out.result = state->tmp.out.result;

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_winsif_WinsResetCounters_recv(struct tevent_req *req,
					      TALLOC_CTX *mem_ctx,
					      WERROR *result)
{
	struct dcerpc_winsif_WinsResetCounters_state *state = tevent_req_data(
		req, struct dcerpc_winsif_WinsResetCounters_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	/* Return result */
	*result = state->orig.out.result;

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_winsif_WinsResetCounters(struct dcerpc_binding_handle *h,
					 TALLOC_CTX *mem_ctx,
					 WERROR *result)
{
	struct winsif_WinsResetCounters r;
	NTSTATUS status;

	/* In parameters */

	/* Out parameters */

	/* Result */
	ZERO_STRUCT(r.out.result);

	status = dcerpc_winsif_WinsResetCounters_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */

	/* Return result */
	*result = r.out.result;

	return NT_STATUS_OK;
}

struct dcerpc_winsif_WinsWorkerThreadUpdate_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_winsif_WinsWorkerThreadUpdate_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_winsif_WinsWorkerThreadUpdate_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct winsif_WinsWorkerThreadUpdate *r)
{
	struct tevent_req *req;
	struct dcerpc_winsif_WinsWorkerThreadUpdate_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_winsif_WinsWorkerThreadUpdate_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = NULL;

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_winsif,
			NDR_WINSIF_WINSWORKERTHREADUPDATE, state, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_winsif_WinsWorkerThreadUpdate_r_done, req);

	return req;
}

static void dcerpc_winsif_WinsWorkerThreadUpdate_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	TALLOC_FREE(subreq);
	if (tevent_req_nterror(req, status)) {
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_winsif_WinsWorkerThreadUpdate_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_winsif_WinsWorkerThreadUpdate_r_state *state =
		tevent_req_data(req,
		struct dcerpc_winsif_WinsWorkerThreadUpdate_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_winsif_WinsWorkerThreadUpdate_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct winsif_WinsWorkerThreadUpdate *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_winsif,
			NDR_WINSIF_WINSWORKERTHREADUPDATE, mem_ctx, r);

	return status;
}

struct dcerpc_winsif_WinsWorkerThreadUpdate_state {
	struct winsif_WinsWorkerThreadUpdate orig;
	struct winsif_WinsWorkerThreadUpdate tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_winsif_WinsWorkerThreadUpdate_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_winsif_WinsWorkerThreadUpdate_send(TALLOC_CTX *mem_ctx,
							     struct tevent_context *ev,
							     struct dcerpc_binding_handle *h,
							     uint32_t _num_of_threads /* [in]  */)
{
	struct tevent_req *req;
	struct dcerpc_winsif_WinsWorkerThreadUpdate_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_winsif_WinsWorkerThreadUpdate_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.num_of_threads = _num_of_threads;

	/* Out parameters */

	/* Result */
	ZERO_STRUCT(state->orig.out.result);

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_winsif_WinsWorkerThreadUpdate_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_winsif_WinsWorkerThreadUpdate_done, req);
	return req;
}

static void dcerpc_winsif_WinsWorkerThreadUpdate_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_winsif_WinsWorkerThreadUpdate_state *state = tevent_req_data(
		req, struct dcerpc_winsif_WinsWorkerThreadUpdate_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_winsif_WinsWorkerThreadUpdate_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (tevent_req_nterror(req, status)) {
		return;
	}

	/* Copy out parameters */

	/* Copy result */
	state->orig.out.result = state->tmp.out.result;

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_winsif_WinsWorkerThreadUpdate_recv(struct tevent_req *req,
						   TALLOC_CTX *mem_ctx,
						   WERROR *result)
{
	struct dcerpc_winsif_WinsWorkerThreadUpdate_state *state = tevent_req_data(
		req, struct dcerpc_winsif_WinsWorkerThreadUpdate_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	/* Return result */
	*result = state->orig.out.result;

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_winsif_WinsWorkerThreadUpdate(struct dcerpc_binding_handle *h,
					      TALLOC_CTX *mem_ctx,
					      uint32_t _num_of_threads /* [in]  */,
					      WERROR *result)
{
	struct winsif_WinsWorkerThreadUpdate r;
	NTSTATUS status;

	/* In parameters */
	r.in.num_of_threads = _num_of_threads;

	/* Out parameters */

	/* Result */
	ZERO_STRUCT(r.out.result);

	status = dcerpc_winsif_WinsWorkerThreadUpdate_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */

	/* Return result */
	*result = r.out.result;

	return NT_STATUS_OK;
}

struct dcerpc_winsif_WinsGetNameAndAdd_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_winsif_WinsGetNameAndAdd_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_winsif_WinsGetNameAndAdd_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct winsif_WinsGetNameAndAdd *r)
{
	struct tevent_req *req;
	struct dcerpc_winsif_WinsGetNameAndAdd_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_winsif_WinsGetNameAndAdd_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = talloc_new(state);
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_winsif,
			NDR_WINSIF_WINSGETNAMEANDADD, state->out_mem_ctx, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_winsif_WinsGetNameAndAdd_r_done, req);

	return req;
}

static void dcerpc_winsif_WinsGetNameAndAdd_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	TALLOC_FREE(subreq);
	if (tevent_req_nterror(req, status)) {
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_winsif_WinsGetNameAndAdd_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_winsif_WinsGetNameAndAdd_r_state *state =
		tevent_req_data(req,
		struct dcerpc_winsif_WinsGetNameAndAdd_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_winsif_WinsGetNameAndAdd_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct winsif_WinsGetNameAndAdd *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_winsif,
			NDR_WINSIF_WINSGETNAMEANDADD, mem_ctx, r);

	return status;
}

struct dcerpc_winsif_WinsGetNameAndAdd_state {
	struct winsif_WinsGetNameAndAdd orig;
	struct winsif_WinsGetNameAndAdd tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_winsif_WinsGetNameAndAdd_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_winsif_WinsGetNameAndAdd_send(TALLOC_CTX *mem_ctx,
							struct tevent_context *ev,
							struct dcerpc_binding_handle *h,
							struct winsif_Address *_server_address /* [out] [ref] */,
							const char *_unc_name /* [out] [charset(DOS),ref,size_is(80)] */)
{
	struct tevent_req *req;
	struct dcerpc_winsif_WinsGetNameAndAdd_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_winsif_WinsGetNameAndAdd_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */

	/* Out parameters */
	state->orig.out.server_address = _server_address;
	state->orig.out.unc_name = _unc_name;

	/* Result */
	ZERO_STRUCT(state->orig.out.result);

	state->out_mem_ctx = talloc_named_const(state, 0,
			     "dcerpc_winsif_WinsGetNameAndAdd_out_memory");
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_winsif_WinsGetNameAndAdd_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_winsif_WinsGetNameAndAdd_done, req);
	return req;
}

static void dcerpc_winsif_WinsGetNameAndAdd_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_winsif_WinsGetNameAndAdd_state *state = tevent_req_data(
		req, struct dcerpc_winsif_WinsGetNameAndAdd_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_winsif_WinsGetNameAndAdd_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (tevent_req_nterror(req, status)) {
		return;
	}

	/* Copy out parameters */
	*state->orig.out.server_address = *state->tmp.out.server_address;
	{
		size_t _copy_len_unc_name;
		_copy_len_unc_name = ndr_charset_length(state->tmp.out.unc_name, CH_UNIX);
		if (_copy_len_unc_name > 80) {
			tevent_req_nterror(req, NT_STATUS_INVALID_NETWORK_RESPONSE);
			return;
		}
		if (state->orig.out.unc_name != state->tmp.out.unc_name) {
			memcpy(discard_const_p(uint8_t *, state->orig.out.unc_name), state->tmp.out.unc_name, _copy_len_unc_name * sizeof(*state->orig.out.unc_name));
		}
	}

	/* Copy result */
	state->orig.out.result = state->tmp.out.result;

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_winsif_WinsGetNameAndAdd_recv(struct tevent_req *req,
					      TALLOC_CTX *mem_ctx,
					      WERROR *result)
{
	struct dcerpc_winsif_WinsGetNameAndAdd_state *state = tevent_req_data(
		req, struct dcerpc_winsif_WinsGetNameAndAdd_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	/* Return result */
	*result = state->orig.out.result;

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_winsif_WinsGetNameAndAdd(struct dcerpc_binding_handle *h,
					 TALLOC_CTX *mem_ctx,
					 struct winsif_Address *_server_address /* [out] [ref] */,
					 const char *_unc_name /* [out] [charset(DOS),ref,size_is(80)] */,
					 WERROR *result)
{
	struct winsif_WinsGetNameAndAdd r;
	NTSTATUS status;

	/* In parameters */

	/* Out parameters */
	r.out.server_address = _server_address;
	r.out.unc_name = _unc_name;

	/* Result */
	ZERO_STRUCT(r.out.result);

	status = dcerpc_winsif_WinsGetNameAndAdd_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */
	*_server_address = *r.out.server_address;
	{
		size_t _copy_len_unc_name;
		_copy_len_unc_name = ndr_charset_length(r.out.unc_name, CH_UNIX);
		if (_copy_len_unc_name > 80) {
			return NT_STATUS_INVALID_NETWORK_RESPONSE;
		}
		if (_unc_name != r.out.unc_name) {
			memcpy(discard_const_p(uint8_t *, _unc_name), r.out.unc_name, _copy_len_unc_name * sizeof(*_unc_name));
		}
	}

	/* Return result */
	*result = r.out.result;

	return NT_STATUS_OK;
}

struct dcerpc_winsif_WinsGetBrowserNames_Old_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_winsif_WinsGetBrowserNames_Old_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_winsif_WinsGetBrowserNames_Old_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct winsif_WinsGetBrowserNames_Old *r)
{
	struct tevent_req *req;
	struct dcerpc_winsif_WinsGetBrowserNames_Old_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_winsif_WinsGetBrowserNames_Old_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = talloc_new(state);
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_winsif,
			NDR_WINSIF_WINSGETBROWSERNAMES_OLD, state->out_mem_ctx, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_winsif_WinsGetBrowserNames_Old_r_done, req);

	return req;
}

static void dcerpc_winsif_WinsGetBrowserNames_Old_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	TALLOC_FREE(subreq);
	if (tevent_req_nterror(req, status)) {
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_winsif_WinsGetBrowserNames_Old_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_winsif_WinsGetBrowserNames_Old_r_state *state =
		tevent_req_data(req,
		struct dcerpc_winsif_WinsGetBrowserNames_Old_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_winsif_WinsGetBrowserNames_Old_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct winsif_WinsGetBrowserNames_Old *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_winsif,
			NDR_WINSIF_WINSGETBROWSERNAMES_OLD, mem_ctx, r);

	return status;
}

struct dcerpc_winsif_WinsGetBrowserNames_Old_state {
	struct winsif_WinsGetBrowserNames_Old orig;
	struct winsif_WinsGetBrowserNames_Old tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_winsif_WinsGetBrowserNames_Old_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_winsif_WinsGetBrowserNames_Old_send(TALLOC_CTX *mem_ctx,
							      struct tevent_context *ev,
							      struct dcerpc_binding_handle *h,
							      struct winsif_BrowserNames *_names /* [out] [ref] */)
{
	struct tevent_req *req;
	struct dcerpc_winsif_WinsGetBrowserNames_Old_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_winsif_WinsGetBrowserNames_Old_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */

	/* Out parameters */
	state->orig.out.names = _names;

	/* Result */
	ZERO_STRUCT(state->orig.out.result);

	state->out_mem_ctx = talloc_named_const(state, 0,
			     "dcerpc_winsif_WinsGetBrowserNames_Old_out_memory");
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_winsif_WinsGetBrowserNames_Old_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_winsif_WinsGetBrowserNames_Old_done, req);
	return req;
}

static void dcerpc_winsif_WinsGetBrowserNames_Old_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_winsif_WinsGetBrowserNames_Old_state *state = tevent_req_data(
		req, struct dcerpc_winsif_WinsGetBrowserNames_Old_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_winsif_WinsGetBrowserNames_Old_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (tevent_req_nterror(req, status)) {
		return;
	}

	/* Copy out parameters */
	*state->orig.out.names = *state->tmp.out.names;

	/* Copy result */
	state->orig.out.result = state->tmp.out.result;

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_winsif_WinsGetBrowserNames_Old_recv(struct tevent_req *req,
						    TALLOC_CTX *mem_ctx,
						    WERROR *result)
{
	struct dcerpc_winsif_WinsGetBrowserNames_Old_state *state = tevent_req_data(
		req, struct dcerpc_winsif_WinsGetBrowserNames_Old_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	/* Return result */
	*result = state->orig.out.result;

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_winsif_WinsGetBrowserNames_Old(struct dcerpc_binding_handle *h,
					       TALLOC_CTX *mem_ctx,
					       struct winsif_BrowserNames *_names /* [out] [ref] */,
					       WERROR *result)
{
	struct winsif_WinsGetBrowserNames_Old r;
	NTSTATUS status;

	/* In parameters */

	/* Out parameters */
	r.out.names = _names;

	/* Result */
	ZERO_STRUCT(r.out.result);

	status = dcerpc_winsif_WinsGetBrowserNames_Old_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */
	*_names = *r.out.names;

	/* Return result */
	*result = r.out.result;

	return NT_STATUS_OK;
}

struct dcerpc_winsif_WinsDeleteWins_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_winsif_WinsDeleteWins_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_winsif_WinsDeleteWins_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct winsif_WinsDeleteWins *r)
{
	struct tevent_req *req;
	struct dcerpc_winsif_WinsDeleteWins_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_winsif_WinsDeleteWins_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = NULL;

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_winsif,
			NDR_WINSIF_WINSDELETEWINS, state, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_winsif_WinsDeleteWins_r_done, req);

	return req;
}

static void dcerpc_winsif_WinsDeleteWins_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	TALLOC_FREE(subreq);
	if (tevent_req_nterror(req, status)) {
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_winsif_WinsDeleteWins_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_winsif_WinsDeleteWins_r_state *state =
		tevent_req_data(req,
		struct dcerpc_winsif_WinsDeleteWins_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_winsif_WinsDeleteWins_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct winsif_WinsDeleteWins *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_winsif,
			NDR_WINSIF_WINSDELETEWINS, mem_ctx, r);

	return status;
}

struct dcerpc_winsif_WinsDeleteWins_state {
	struct winsif_WinsDeleteWins orig;
	struct winsif_WinsDeleteWins tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_winsif_WinsDeleteWins_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_winsif_WinsDeleteWins_send(TALLOC_CTX *mem_ctx,
						     struct tevent_context *ev,
						     struct dcerpc_binding_handle *h,
						     struct winsif_Address *_owner_address /* [in] [ref] */)
{
	struct tevent_req *req;
	struct dcerpc_winsif_WinsDeleteWins_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_winsif_WinsDeleteWins_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.owner_address = _owner_address;

	/* Out parameters */

	/* Result */
	ZERO_STRUCT(state->orig.out.result);

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_winsif_WinsDeleteWins_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_winsif_WinsDeleteWins_done, req);
	return req;
}

static void dcerpc_winsif_WinsDeleteWins_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_winsif_WinsDeleteWins_state *state = tevent_req_data(
		req, struct dcerpc_winsif_WinsDeleteWins_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_winsif_WinsDeleteWins_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (tevent_req_nterror(req, status)) {
		return;
	}

	/* Copy out parameters */

	/* Copy result */
	state->orig.out.result = state->tmp.out.result;

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_winsif_WinsDeleteWins_recv(struct tevent_req *req,
					   TALLOC_CTX *mem_ctx,
					   WERROR *result)
{
	struct dcerpc_winsif_WinsDeleteWins_state *state = tevent_req_data(
		req, struct dcerpc_winsif_WinsDeleteWins_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	/* Return result */
	*result = state->orig.out.result;

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_winsif_WinsDeleteWins(struct dcerpc_binding_handle *h,
				      TALLOC_CTX *mem_ctx,
				      struct winsif_Address *_owner_address /* [in] [ref] */,
				      WERROR *result)
{
	struct winsif_WinsDeleteWins r;
	NTSTATUS status;

	/* In parameters */
	r.in.owner_address = _owner_address;

	/* Out parameters */

	/* Result */
	ZERO_STRUCT(r.out.result);

	status = dcerpc_winsif_WinsDeleteWins_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */

	/* Return result */
	*result = r.out.result;

	return NT_STATUS_OK;
}

struct dcerpc_winsif_WinsSetFlags_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_winsif_WinsSetFlags_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_winsif_WinsSetFlags_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct winsif_WinsSetFlags *r)
{
	struct tevent_req *req;
	struct dcerpc_winsif_WinsSetFlags_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_winsif_WinsSetFlags_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = NULL;

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_winsif,
			NDR_WINSIF_WINSSETFLAGS, state, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_winsif_WinsSetFlags_r_done, req);

	return req;
}

static void dcerpc_winsif_WinsSetFlags_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	TALLOC_FREE(subreq);
	if (tevent_req_nterror(req, status)) {
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_winsif_WinsSetFlags_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_winsif_WinsSetFlags_r_state *state =
		tevent_req_data(req,
		struct dcerpc_winsif_WinsSetFlags_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_winsif_WinsSetFlags_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct winsif_WinsSetFlags *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_winsif,
			NDR_WINSIF_WINSSETFLAGS, mem_ctx, r);

	return status;
}

struct dcerpc_winsif_WinsSetFlags_state {
	struct winsif_WinsSetFlags orig;
	struct winsif_WinsSetFlags tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_winsif_WinsSetFlags_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_winsif_WinsSetFlags_send(TALLOC_CTX *mem_ctx,
						   struct tevent_context *ev,
						   struct dcerpc_binding_handle *h,
						   uint32_t _flags /* [in]  */)
{
	struct tevent_req *req;
	struct dcerpc_winsif_WinsSetFlags_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_winsif_WinsSetFlags_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.flags = _flags;

	/* Out parameters */

	/* Result */
	ZERO_STRUCT(state->orig.out.result);

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_winsif_WinsSetFlags_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_winsif_WinsSetFlags_done, req);
	return req;
}

static void dcerpc_winsif_WinsSetFlags_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_winsif_WinsSetFlags_state *state = tevent_req_data(
		req, struct dcerpc_winsif_WinsSetFlags_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_winsif_WinsSetFlags_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (tevent_req_nterror(req, status)) {
		return;
	}

	/* Copy out parameters */

	/* Copy result */
	state->orig.out.result = state->tmp.out.result;

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_winsif_WinsSetFlags_recv(struct tevent_req *req,
					 TALLOC_CTX *mem_ctx,
					 WERROR *result)
{
	struct dcerpc_winsif_WinsSetFlags_state *state = tevent_req_data(
		req, struct dcerpc_winsif_WinsSetFlags_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	/* Return result */
	*result = state->orig.out.result;

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_winsif_WinsSetFlags(struct dcerpc_binding_handle *h,
				    TALLOC_CTX *mem_ctx,
				    uint32_t _flags /* [in]  */,
				    WERROR *result)
{
	struct winsif_WinsSetFlags r;
	NTSTATUS status;

	/* In parameters */
	r.in.flags = _flags;

	/* Out parameters */

	/* Result */
	ZERO_STRUCT(r.out.result);

	status = dcerpc_winsif_WinsSetFlags_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */

	/* Return result */
	*result = r.out.result;

	return NT_STATUS_OK;
}

struct dcerpc_winsif_WinsGetBrowserNames_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_winsif_WinsGetBrowserNames_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_winsif_WinsGetBrowserNames_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct winsif_WinsGetBrowserNames *r)
{
	struct tevent_req *req;
	struct dcerpc_winsif_WinsGetBrowserNames_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_winsif_WinsGetBrowserNames_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = talloc_new(state);
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_winsif,
			NDR_WINSIF_WINSGETBROWSERNAMES, state->out_mem_ctx, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_winsif_WinsGetBrowserNames_r_done, req);

	return req;
}

static void dcerpc_winsif_WinsGetBrowserNames_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	TALLOC_FREE(subreq);
	if (tevent_req_nterror(req, status)) {
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_winsif_WinsGetBrowserNames_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_winsif_WinsGetBrowserNames_r_state *state =
		tevent_req_data(req,
		struct dcerpc_winsif_WinsGetBrowserNames_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_winsif_WinsGetBrowserNames_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct winsif_WinsGetBrowserNames *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_winsif,
			NDR_WINSIF_WINSGETBROWSERNAMES, mem_ctx, r);

	return status;
}

struct dcerpc_winsif_WinsGetBrowserNames_state {
	struct winsif_WinsGetBrowserNames orig;
	struct winsif_WinsGetBrowserNames tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_winsif_WinsGetBrowserNames_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_winsif_WinsGetBrowserNames_send(TALLOC_CTX *mem_ctx,
							  struct tevent_context *ev,
							  struct dcerpc_binding_handle *h,
							  struct winsif_BindData *_server_handle /* [in] [ref] */,
							  struct winsif_BrowserNames *_names /* [out] [ref] */)
{
	struct tevent_req *req;
	struct dcerpc_winsif_WinsGetBrowserNames_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_winsif_WinsGetBrowserNames_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.server_handle = _server_handle;

	/* Out parameters */
	state->orig.out.names = _names;

	/* Result */
	ZERO_STRUCT(state->orig.out.result);

	state->out_mem_ctx = talloc_named_const(state, 0,
			     "dcerpc_winsif_WinsGetBrowserNames_out_memory");
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_winsif_WinsGetBrowserNames_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_winsif_WinsGetBrowserNames_done, req);
	return req;
}

static void dcerpc_winsif_WinsGetBrowserNames_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_winsif_WinsGetBrowserNames_state *state = tevent_req_data(
		req, struct dcerpc_winsif_WinsGetBrowserNames_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_winsif_WinsGetBrowserNames_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (tevent_req_nterror(req, status)) {
		return;
	}

	/* Copy out parameters */
	*state->orig.out.names = *state->tmp.out.names;

	/* Copy result */
	state->orig.out.result = state->tmp.out.result;

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_winsif_WinsGetBrowserNames_recv(struct tevent_req *req,
						TALLOC_CTX *mem_ctx,
						WERROR *result)
{
	struct dcerpc_winsif_WinsGetBrowserNames_state *state = tevent_req_data(
		req, struct dcerpc_winsif_WinsGetBrowserNames_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	/* Return result */
	*result = state->orig.out.result;

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_winsif_WinsGetBrowserNames(struct dcerpc_binding_handle *h,
					   TALLOC_CTX *mem_ctx,
					   struct winsif_BindData *_server_handle /* [in] [ref] */,
					   struct winsif_BrowserNames *_names /* [out] [ref] */,
					   WERROR *result)
{
	struct winsif_WinsGetBrowserNames r;
	NTSTATUS status;

	/* In parameters */
	r.in.server_handle = _server_handle;

	/* Out parameters */
	r.out.names = _names;

	/* Result */
	ZERO_STRUCT(r.out.result);

	status = dcerpc_winsif_WinsGetBrowserNames_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */
	*_names = *r.out.names;

	/* Return result */
	*result = r.out.result;

	return NT_STATUS_OK;
}

struct dcerpc_winsif_WinsGetDbRecsByName_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_winsif_WinsGetDbRecsByName_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_winsif_WinsGetDbRecsByName_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct winsif_WinsGetDbRecsByName *r)
{
	struct tevent_req *req;
	struct dcerpc_winsif_WinsGetDbRecsByName_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_winsif_WinsGetDbRecsByName_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = talloc_new(state);
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_winsif,
			NDR_WINSIF_WINSGETDBRECSBYNAME, state->out_mem_ctx, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_winsif_WinsGetDbRecsByName_r_done, req);

	return req;
}

static void dcerpc_winsif_WinsGetDbRecsByName_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	TALLOC_FREE(subreq);
	if (tevent_req_nterror(req, status)) {
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_winsif_WinsGetDbRecsByName_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_winsif_WinsGetDbRecsByName_r_state *state =
		tevent_req_data(req,
		struct dcerpc_winsif_WinsGetDbRecsByName_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_winsif_WinsGetDbRecsByName_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct winsif_WinsGetDbRecsByName *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_winsif,
			NDR_WINSIF_WINSGETDBRECSBYNAME, mem_ctx, r);

	return status;
}

struct dcerpc_winsif_WinsGetDbRecsByName_state {
	struct winsif_WinsGetDbRecsByName orig;
	struct winsif_WinsGetDbRecsByName tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_winsif_WinsGetDbRecsByName_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_winsif_WinsGetDbRecsByName_send(TALLOC_CTX *mem_ctx,
							  struct tevent_context *ev,
							  struct dcerpc_binding_handle *h,
							  struct winsif_Address *_owner_address /* [in] [unique] */,
							  uint32_t _search_backward /* [in]  */,
							  struct nbt_name * _name /* [in] [unique] */,
							  uint32_t _name_len /* [in] [range(0,16),value(name?16:0)] */,
							  uint32_t _num_records_desired /* [in]  */,
							  uint32_t _only_statics /* [in]  */,
							  struct winsif_Records *_records /* [out] [ref] */)
{
	struct tevent_req *req;
	struct dcerpc_winsif_WinsGetDbRecsByName_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_winsif_WinsGetDbRecsByName_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.owner_address = _owner_address;
	state->orig.in.search_backward = _search_backward;
	state->orig.in.name = _name;
	state->orig.in.name_len = _name_len;
	state->orig.in.num_records_desired = _num_records_desired;
	state->orig.in.only_statics = _only_statics;

	/* Out parameters */
	state->orig.out.records = _records;

	/* Result */
	ZERO_STRUCT(state->orig.out.result);

	state->out_mem_ctx = talloc_named_const(state, 0,
			     "dcerpc_winsif_WinsGetDbRecsByName_out_memory");
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_winsif_WinsGetDbRecsByName_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_winsif_WinsGetDbRecsByName_done, req);
	return req;
}

static void dcerpc_winsif_WinsGetDbRecsByName_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_winsif_WinsGetDbRecsByName_state *state = tevent_req_data(
		req, struct dcerpc_winsif_WinsGetDbRecsByName_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_winsif_WinsGetDbRecsByName_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (tevent_req_nterror(req, status)) {
		return;
	}

	/* Copy out parameters */
	*state->orig.out.records = *state->tmp.out.records;

	/* Copy result */
	state->orig.out.result = state->tmp.out.result;

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_winsif_WinsGetDbRecsByName_recv(struct tevent_req *req,
						TALLOC_CTX *mem_ctx,
						WERROR *result)
{
	struct dcerpc_winsif_WinsGetDbRecsByName_state *state = tevent_req_data(
		req, struct dcerpc_winsif_WinsGetDbRecsByName_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	/* Return result */
	*result = state->orig.out.result;

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_winsif_WinsGetDbRecsByName(struct dcerpc_binding_handle *h,
					   TALLOC_CTX *mem_ctx,
					   struct winsif_Address *_owner_address /* [in] [unique] */,
					   uint32_t _search_backward /* [in]  */,
					   struct nbt_name * _name /* [in] [unique] */,
					   uint32_t _name_len /* [in] [range(0,16),value(name?16:0)] */,
					   uint32_t _num_records_desired /* [in]  */,
					   uint32_t _only_statics /* [in]  */,
					   struct winsif_Records *_records /* [out] [ref] */,
					   WERROR *result)
{
	struct winsif_WinsGetDbRecsByName r;
	NTSTATUS status;

	/* In parameters */
	r.in.owner_address = _owner_address;
	r.in.search_backward = _search_backward;
	r.in.name = _name;
	r.in.name_len = _name_len;
	r.in.num_records_desired = _num_records_desired;
	r.in.only_statics = _only_statics;

	/* Out parameters */
	r.out.records = _records;

	/* Result */
	ZERO_STRUCT(r.out.result);

	status = dcerpc_winsif_WinsGetDbRecsByName_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */
	*_records = *r.out.records;

	/* Return result */
	*result = r.out.result;

	return NT_STATUS_OK;
}

struct dcerpc_winsif_WinsStatusNew_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_winsif_WinsStatusNew_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_winsif_WinsStatusNew_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct winsif_WinsStatusNew *r)
{
	struct tevent_req *req;
	struct dcerpc_winsif_WinsStatusNew_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_winsif_WinsStatusNew_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = talloc_new(state);
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_winsif,
			NDR_WINSIF_WINSSTATUSNEW, state->out_mem_ctx, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_winsif_WinsStatusNew_r_done, req);

	return req;
}

static void dcerpc_winsif_WinsStatusNew_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	TALLOC_FREE(subreq);
	if (tevent_req_nterror(req, status)) {
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_winsif_WinsStatusNew_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_winsif_WinsStatusNew_r_state *state =
		tevent_req_data(req,
		struct dcerpc_winsif_WinsStatusNew_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_winsif_WinsStatusNew_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct winsif_WinsStatusNew *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_winsif,
			NDR_WINSIF_WINSSTATUSNEW, mem_ctx, r);

	return status;
}

struct dcerpc_winsif_WinsStatusNew_state {
	struct winsif_WinsStatusNew orig;
	struct winsif_WinsStatusNew tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_winsif_WinsStatusNew_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_winsif_WinsStatusNew_send(TALLOC_CTX *mem_ctx,
						    struct tevent_context *ev,
						    struct dcerpc_binding_handle *h,
						    enum winsif_StatusCmd _cmd /* [in]  */,
						    struct winsif_ResultsNew *_results /* [out] [ref] */)
{
	struct tevent_req *req;
	struct dcerpc_winsif_WinsStatusNew_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_winsif_WinsStatusNew_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.cmd = _cmd;

	/* Out parameters */
	state->orig.out.results = _results;

	/* Result */
	ZERO_STRUCT(state->orig.out.result);

	state->out_mem_ctx = talloc_named_const(state, 0,
			     "dcerpc_winsif_WinsStatusNew_out_memory");
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_winsif_WinsStatusNew_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_winsif_WinsStatusNew_done, req);
	return req;
}

static void dcerpc_winsif_WinsStatusNew_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_winsif_WinsStatusNew_state *state = tevent_req_data(
		req, struct dcerpc_winsif_WinsStatusNew_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_winsif_WinsStatusNew_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (tevent_req_nterror(req, status)) {
		return;
	}

	/* Copy out parameters */
	*state->orig.out.results = *state->tmp.out.results;

	/* Copy result */
	state->orig.out.result = state->tmp.out.result;

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_winsif_WinsStatusNew_recv(struct tevent_req *req,
					  TALLOC_CTX *mem_ctx,
					  WERROR *result)
{
	struct dcerpc_winsif_WinsStatusNew_state *state = tevent_req_data(
		req, struct dcerpc_winsif_WinsStatusNew_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	/* Return result */
	*result = state->orig.out.result;

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_winsif_WinsStatusNew(struct dcerpc_binding_handle *h,
				     TALLOC_CTX *mem_ctx,
				     enum winsif_StatusCmd _cmd /* [in]  */,
				     struct winsif_ResultsNew *_results /* [out] [ref] */,
				     WERROR *result)
{
	struct winsif_WinsStatusNew r;
	NTSTATUS status;

	/* In parameters */
	r.in.cmd = _cmd;

	/* Out parameters */
	r.out.results = _results;

	/* Result */
	ZERO_STRUCT(r.out.result);

	status = dcerpc_winsif_WinsStatusNew_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */
	*_results = *r.out.results;

	/* Return result */
	*result = r.out.result;

	return NT_STATUS_OK;
}

struct dcerpc_winsif_WinsStatusWHdl_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_winsif_WinsStatusWHdl_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_winsif_WinsStatusWHdl_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct winsif_WinsStatusWHdl *r)
{
	struct tevent_req *req;
	struct dcerpc_winsif_WinsStatusWHdl_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_winsif_WinsStatusWHdl_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = talloc_new(state);
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_winsif,
			NDR_WINSIF_WINSSTATUSWHDL, state->out_mem_ctx, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_winsif_WinsStatusWHdl_r_done, req);

	return req;
}

static void dcerpc_winsif_WinsStatusWHdl_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	TALLOC_FREE(subreq);
	if (tevent_req_nterror(req, status)) {
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_winsif_WinsStatusWHdl_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_winsif_WinsStatusWHdl_r_state *state =
		tevent_req_data(req,
		struct dcerpc_winsif_WinsStatusWHdl_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_winsif_WinsStatusWHdl_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct winsif_WinsStatusWHdl *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_winsif,
			NDR_WINSIF_WINSSTATUSWHDL, mem_ctx, r);

	return status;
}

struct dcerpc_winsif_WinsStatusWHdl_state {
	struct winsif_WinsStatusWHdl orig;
	struct winsif_WinsStatusWHdl tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_winsif_WinsStatusWHdl_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_winsif_WinsStatusWHdl_send(TALLOC_CTX *mem_ctx,
						     struct tevent_context *ev,
						     struct dcerpc_binding_handle *h,
						     struct winsif_BindData *_server_handle /* [in] [ref] */,
						     enum winsif_StatusCmd _cmd /* [in]  */,
						     struct winsif_ResultsNew *_results /* [in,out] [ref] */)
{
	struct tevent_req *req;
	struct dcerpc_winsif_WinsStatusWHdl_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_winsif_WinsStatusWHdl_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.server_handle = _server_handle;
	state->orig.in.cmd = _cmd;
	state->orig.in.results = _results;

	/* Out parameters */
	state->orig.out.results = _results;

	/* Result */
	ZERO_STRUCT(state->orig.out.result);

	state->out_mem_ctx = talloc_named_const(state, 0,
			     "dcerpc_winsif_WinsStatusWHdl_out_memory");
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_winsif_WinsStatusWHdl_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_winsif_WinsStatusWHdl_done, req);
	return req;
}

static void dcerpc_winsif_WinsStatusWHdl_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_winsif_WinsStatusWHdl_state *state = tevent_req_data(
		req, struct dcerpc_winsif_WinsStatusWHdl_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_winsif_WinsStatusWHdl_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (tevent_req_nterror(req, status)) {
		return;
	}

	/* Copy out parameters */
	*state->orig.out.results = *state->tmp.out.results;

	/* Copy result */
	state->orig.out.result = state->tmp.out.result;

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_winsif_WinsStatusWHdl_recv(struct tevent_req *req,
					   TALLOC_CTX *mem_ctx,
					   WERROR *result)
{
	struct dcerpc_winsif_WinsStatusWHdl_state *state = tevent_req_data(
		req, struct dcerpc_winsif_WinsStatusWHdl_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	/* Return result */
	*result = state->orig.out.result;

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_winsif_WinsStatusWHdl(struct dcerpc_binding_handle *h,
				      TALLOC_CTX *mem_ctx,
				      struct winsif_BindData *_server_handle /* [in] [ref] */,
				      enum winsif_StatusCmd _cmd /* [in]  */,
				      struct winsif_ResultsNew *_results /* [in,out] [ref] */,
				      WERROR *result)
{
	struct winsif_WinsStatusWHdl r;
	NTSTATUS status;

	/* In parameters */
	r.in.server_handle = _server_handle;
	r.in.cmd = _cmd;
	r.in.results = _results;

	/* Out parameters */
	r.out.results = _results;

	/* Result */
	ZERO_STRUCT(r.out.result);

	status = dcerpc_winsif_WinsStatusWHdl_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */
	*_results = *r.out.results;

	/* Return result */
	*result = r.out.result;

	return NT_STATUS_OK;
}

struct dcerpc_winsif_WinsDoScanvengingNew_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_winsif_WinsDoScanvengingNew_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_winsif_WinsDoScanvengingNew_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct winsif_WinsDoScanvengingNew *r)
{
	struct tevent_req *req;
	struct dcerpc_winsif_WinsDoScanvengingNew_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_winsif_WinsDoScanvengingNew_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = NULL;

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_winsif,
			NDR_WINSIF_WINSDOSCANVENGINGNEW, state, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_winsif_WinsDoScanvengingNew_r_done, req);

	return req;
}

static void dcerpc_winsif_WinsDoScanvengingNew_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	TALLOC_FREE(subreq);
	if (tevent_req_nterror(req, status)) {
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_winsif_WinsDoScanvengingNew_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_winsif_WinsDoScanvengingNew_r_state *state =
		tevent_req_data(req,
		struct dcerpc_winsif_WinsDoScanvengingNew_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_winsif_WinsDoScanvengingNew_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct winsif_WinsDoScanvengingNew *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_winsif,
			NDR_WINSIF_WINSDOSCANVENGINGNEW, mem_ctx, r);

	return status;
}

struct dcerpc_winsif_WinsDoScanvengingNew_state {
	struct winsif_WinsDoScanvengingNew orig;
	struct winsif_WinsDoScanvengingNew tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_winsif_WinsDoScanvengingNew_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_winsif_WinsDoScanvengingNew_send(TALLOC_CTX *mem_ctx,
							   struct tevent_context *ev,
							   struct dcerpc_binding_handle *h,
							   struct winsif_ScavengingRequest *_request /* [in] [ref] */)
{
	struct tevent_req *req;
	struct dcerpc_winsif_WinsDoScanvengingNew_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_winsif_WinsDoScanvengingNew_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.request = _request;

	/* Out parameters */

	/* Result */
	ZERO_STRUCT(state->orig.out.result);

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_winsif_WinsDoScanvengingNew_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_winsif_WinsDoScanvengingNew_done, req);
	return req;
}

static void dcerpc_winsif_WinsDoScanvengingNew_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_winsif_WinsDoScanvengingNew_state *state = tevent_req_data(
		req, struct dcerpc_winsif_WinsDoScanvengingNew_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_winsif_WinsDoScanvengingNew_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (tevent_req_nterror(req, status)) {
		return;
	}

	/* Copy out parameters */

	/* Copy result */
	state->orig.out.result = state->tmp.out.result;

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_winsif_WinsDoScanvengingNew_recv(struct tevent_req *req,
						 TALLOC_CTX *mem_ctx,
						 WERROR *result)
{
	struct dcerpc_winsif_WinsDoScanvengingNew_state *state = tevent_req_data(
		req, struct dcerpc_winsif_WinsDoScanvengingNew_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	/* Return result */
	*result = state->orig.out.result;

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_winsif_WinsDoScanvengingNew(struct dcerpc_binding_handle *h,
					    TALLOC_CTX *mem_ctx,
					    struct winsif_ScavengingRequest *_request /* [in] [ref] */,
					    WERROR *result)
{
	struct winsif_WinsDoScanvengingNew r;
	NTSTATUS status;

	/* In parameters */
	r.in.request = _request;

	/* Out parameters */

	/* Result */
	ZERO_STRUCT(r.out.result);

	status = dcerpc_winsif_WinsDoScanvengingNew_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */

	/* Return result */
	*result = r.out.result;

	return NT_STATUS_OK;
}

